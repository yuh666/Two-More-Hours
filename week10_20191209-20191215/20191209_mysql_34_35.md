## 数据恢复

1. delete 语句误删行数据
   - 通过flashback恢复数据,流程根据binlog日志配置binlog_format=row,如果当前事件是insert语句则转换为delete:id  update:更新旧数据回去 delete:insert 旧数据
   - 此时操作不应该在主库直接执行,应该在主库备份一个备库后执行,防止对数据进行二次坏
   - 当如果是delete全表的时候,此时通过undo log来回滚数据会很慢
2. 误删库/表
   - 通过binlog日志恢复数据(数据拷贝)
     - 假设数据的备份是按天执行,此时假设当天23点宕机此时,需要取昨天0点备份的完备数据+今天到23点的binlog日志来恢复数据,binlog通过mysqldump来恢复
   - 延时复制备库
     - 当主库执行完sql语句后,设置备库和主库中同步间隔时间比如1小时,如果当进行了误操作时,此时通过备库来恢复数据
   - 账号权限控制
     - 控制账号的读写权限

## kill

1. kill connection:断开客户端与服务端的连接
2. kill query:客户端与服务端的连接未断开,当前线程被标记为THD::KILL_QUERY,当线程在执行过程中某个锚点判断状态时线程终止
3. kill 退出不了的情况
   - 线程不能执行到判断线程状态逻辑:比如select sleep(1000) from 表,kill query thread等待,只能通过kill connection来断开
   - 终止逻辑时间过长:超大事物被kill需要长时间的回滚和删除日志文件
4. 库中表多客户端连接慢
   - -A:客户端不在去通过show tables来缓存数据表名称到客户端,这样查看表是不会有table提示
   - -quick
     - 客户端本地缓存,先将结果存起来,对应api mysql_store_result
     - 读一个客户端处理一个,用api 对应mysql_use_result
     - quick作用:
       - 跳过表名自动补全
       - 采用第二种方式不需要本地缓存,因为使用缓如果查询语句时间较长耗费较大的本地内存,影响客户端的性能
       - 不会把执行命令记录到本地的命令历史文件中