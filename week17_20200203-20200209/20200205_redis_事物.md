## 事务

1. 事物提供了将多个命令请求打包,然后一次性的顺序的执行多个命令请求,执行过程中不会中断事务而去执行其他的请求



## 事务的实现

1. 开启事物

   - ```java
     -- 客户端从非事物切换到事物
     multi
     ```

   - 实现方案:修改redisClient的flags标志位redis_multi

2. 命令入队

   - 判断客户端是否属于事物状态
   - 判断命令是否是exec discard watch multi,是则立即执行
   - 不是则交给添加到事物队列中,返回客户端Queued

3. 事物队列

   - 事物队列维护一个FIFO先进先出的队列(数组)和入队命令计数count,队列中每个元素为multiCmd

   - multiCmd:

     - argv:参数

     - argc:参数的数量

     - cmd:命令指针

     - ```java
       set key01 value01
       argv为数组为3的 [0]:set [1]:key01  [2]:value01  每个值为stringObject类型
       argc:3
       cmd:setCommand
       ```

4. 执行事物

   - 当接收到exec指令时,遍历事物队列执行所有命令,最后在将结果返回给客户端(回复:回复队列),同时清空redisClient的状态和事物队列



## watch命令实现

1. 监听指定键的改变,在redisDb中通过字典存储watched_keys,key:键 value:监听当前键的客户端
2. 在事物执行过程中相当于乐观锁的机制,当指定watch指定后,db中比如lpush set等指定执行时都会执行touchWatchKey方法,根据key去查找监听key的客户端修改这些客户端的标识为redis_dirty_cas(提交事物会失败)



## 事物的ACID

1. 原子性:多个命令操作要么全部执行,要么全部不执行;比如watch监听key改变redisClient变为redis_dirty_cas全部不执行,redis_multi则全部执行(执行过程中可能执行错误);redis不支持事物的回滚操作(设计的初衷,执行错误一般都是命令不熟悉语法错误)
2. 一致性:事物执行之后,不管成功还是失败数据库是一致性的(即不包含非法或无效的错误数据)
   - 入队错误:命令在command表不存在
   - 执行错误:比如当前message为string类型执行lpush message value01 value02
   - 服务器停机:不管是否开启持久化方式和之前状态保持一致
3. 隔离性:多个事物同时执行时,相互之间隔离,因为redis是单线程的每次只会执行一个事物
4. 耐久性:执行事物的结果被永久性的保存到了磁盘上,即是宕机也不会出现数据丢失
   - 无持久化:数据丢失不具备耐久性
   - rdb:当bgsave未被执行时数据会丢失不具备耐久性
   - aof:同步时appendfsync为everysec和no都会出现os cache中数据丢失,当always,如果出现aof文件的rewrite操作,因为rewrite操作时同步会停止为了减少i/o的阻塞此时也不具备耐久性,其他情况always具备耐久性