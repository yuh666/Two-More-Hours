## 布隆过滤器

1. 应用场景:判断某个key是否存在,用来解决去重问题如果我们通过set去重时每次都需要变量进行exists查询

2. 原理:当进行bf.add key user1操作时,会将key通过多个hash函数算等一个整数的索引值然后与位数组取模得到下标然后将多个hash函数得到的下标在位数据中填充1即完成set操作

3. ```java
   bf.add codehole user1
   bf.add codehole user2
   bf.add codehole user3
   bf.exists codehole user1 返回1
   bf.exists codehole user4 返回0
   ```

4. 布隆过滤器认为不存在的元素一定不存在,认为存在的元素不一定存在(因为同一个key可能通过hash函数得到相同的下标)

5. java api pom依赖

   ```java
   <dependency>
     <groupId>com.redislabs</groupId>
     <artifactId>jrebloom</artifactId>
     <version>1.2.0</version>
   </dependency>
   ```



## 限流

1. 比如限制同一个用户在60s内只能点击12次,限流可以通过一个滑动窗口来实现,数据类型选择redis zset,在指定区间的score为窗口有效数据,区间之外为无效数据,value和score即存储当前请求的时候毫秒值

2. 实现方案

   ```java
   /**
    * @author <a href="mailto:zhouzhihui@163.com">wisdom</a>
    * Date: 2020-01-16 08:17
    * version: 1.0
    * Description:限流器:redis zset的滑动窗口
    * 1.规定指定的区间有有效区间 比如限制60s内同一个用户的请求次数不能超过12次 那么窗口即最新的60s区间
    * 2.为什么用zset,数据怎么存储?  zset中 key:当前用户  value:时间戳 分数:时间磋
    * 1.因为通过zset适合将当前判断之前不在60s中数据给删除
    * 2.适合通过最新60s对应的value的个数即请求次数
    **/
   public class TestCurrentLimiter {
   
       private Jedis jedis;
   
       public TestCurrentLimiter(Jedis jedis) {
           this.jedis = jedis;
       }
   
       /**
        * 是否允许点击:false:限制 true:允许
        *
        * @param userId    用户id
        * @param actionKey 事件key
        * @param period    周期即滑动窗口的区间(单位秒)
        * @param maxCount  指定区间最大能点击次数
        * @return
        */
       public boolean isActionAllow(String userId, String actionKey, int period, int maxCount) {
           // 根据操作生成唯一key
           String key = String.format("hist:%s:%s", userId, actionKey);
           // 当前时间毫秒值
           long nowTs = System.currentTimeMillis();
           // 获取jedis的通道,时候进行批量的操作
           Pipeline pipelined = jedis.pipelined();
           // 开启通道事物 通过比如 request01 response01,request02 response02 变成一次批量多个请求,同时返回多个response
           pipelined.multi();
   
           // 0.添加当前key到zset中
           pipelined.zadd(key, nowTs, "" + nowTs);
   
           // 1.删除不在区间的score 即保留当前时间到60s之前的数据
           pipelined.zremrangeByScore(key, 0, nowTs - period * 1000);
   
           // 2.获取滑动区间的score个数
           Response<Long> count = pipelined.zcard(key);
   
           // 3.同时设置过期的key在period+1之后过期 因为窗口只需要保留有效的数据
           pipelined.expire(key, period + 1);
           // 4.执行通道命令
           pipelined.exec();
           // 5.关闭通道
           pipelined.close();
   
           return count.get() <= maxCount;
       }
   
       public static void main(String[] args) {
           TestCurrentLimiter limiter = new TestCurrentLimiter(JedisPoolUtil.getJedisPool().getResource());
           for (int i = 0; i < 100; i++) {
               // 比如60s中只能点击五次
               System.out.println(limiter.isActionAllow("zhouzhihui", "add", 1, 5));
           }
       }
   }
   ```

   