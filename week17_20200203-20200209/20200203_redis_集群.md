## 集群

## 节点

```java
cluster meet ip port
```

1. 当前node节点会跟ip port的节点进行握手,握手成功后将该节点加入到集群中

2. 集群中某个节点和一个节点握手成功后通过gossip来传播信息同步给集群中其他节点

3. 当节点启动时,判断是否开启集群模式(cluster-enabled选项),集群节点的信息通过clusterState和clusterNode clusterLink等结构来存储

4. 实现原理:比如A节点发送cluster meet给B节点

   - A为B创建一个clusterNode结构,添加到自己的clusterState.nodes中
   - A根据B的ip和port给B发送MEET消息
   - B接收到消息后会在B的clusterState.nodes中创建A的clusterNode信息
   - B返回给A一个PONG消息
   - A收到消息后返回给B一个ping消息
   - B接收到后即确认A收到了自己的消息即握手成功

   

## 集群的数据结构

1. clusterState存储集群的状态

   - myself:当前节点的信息

   - state:集群的状态(在线或下线)

   - dict *nodes:通过字典来存储集群中节点的信息,key:node的name value:node信息

   - clusterNode solts[16384]:存储每个槽点所属节点的信息,当通过槽点来查询节点信息时O(1)操作

   - zskiplist slots_to_keys:跳跃表来保存槽和键的关系,这样通过槽定位元素在跳跃表中找指定分数的键比如

     ```java
     hset book name demo age 18
     CRC16(book)&16384=1 1号槽
     则通过跳跃表来关联book(value)和1号槽的关系(score),当往槽中添加元素时维护跳跃表
     ```

   - clusterNode *import_slots_from[16384]:记录当前正在从其他节点导入的槽

   - clusterNode *migrating_slots_to[16384]:当前节点正在迁移至其他节点的槽

2. clusterNode存储节点的信息

   - name:节点名称(40个十六进制)
   - flag:节点标识(主节点/从节点)和(在线/下线) 比如redis_node_master
   - ip port:ip和端口号
   - clusterLink:连接节点的相关信息
   - char solts[16384/8]:来标识当前节点维护的槽信息,一个字节8bit,将槽分配给当前节点或转移O(1)操作
   - numslots:记录当前节点维护槽的数量
   - numslaves:从节点的数量
   - slaves:从节点的信息

3. clusterLink保存了连接节点所需信息

   - sds sndbuf:输出缓冲区,保存发送给其他信息的消息
   - sds rcvbuf:输入缓冲区,保存从其他节点接收到的消息
   - clusterNode *node:与该节点连接的节点信息

4. redisClient和clusterLink的区别

   - redisClient和clusterLink都有输入和输出的缓存区,redisClient:query_buf和buf,clusterLink的sendBuf和receiveBuf;
   - 不同之处在与redisClient是client和server连接时使用;clusterLink是node和node之间通信



## 槽指派

```java
-- 节点添加指定槽
cluster addslots <slot> [slot ....]
-- 查询集群中节点维护的槽信息
cluster nodes
-- 查看集群的状态(当16384个槽都分配给节点后集群才启动成功)
cluster info
-- 返回count个指定槽的数据库键
cluster getkeysinslot slot count(即根据score查询跳跃表O(logN))
```

1. 每个节点维护的槽信息通过消息来传播给其他节点,其他节点更新自己clusterState.nodes中clusterNode的信息
2. cluster addslots的实现原理
   - 判断该槽点是否分配给其他节点即clusterState[i] != null
   - 将槽点指派给自己即更新clusterState[i]=clusterState.myself
   - 根据node中槽信息即clusterState.myself.solts[i]=1



## 集群接收请求

1. 客户端向节点发送数据库指令比如set key01 value01
2. 节点通过CRC16(key)&16383来计算槽位
3. 判断当前槽位是否是当前节点负责即clusterState[i]==clusterState.myself
4. 是当前节点负责,则执行命令返回结果
5. 不是当前节点负责,则判断节点是否在导入槽i
6. 不是则执行moved指令,让客户端去连接节点对应的ip和port
7. 是则判断客户端是否有asking标识,有则当前节点执行该命令 没有则返回moved错误



## 重新分片

1. 由redis-trib负责执行集群的重新分片所需的所有命令
2. 目标节点准备导入槽slot的键值对
3. 源节点准备迁移槽slot的键值对
4. 判断源节点是否保存了属于槽solt的键
5. 未保存,将槽指派给目标节点
6. 保存,将槽上的数据全部迁移到目标节点并将槽指派给目标节点
7. 完成槽的重新分片



## moved和ask错误的区别

1. moved:代表槽的负责区已经从一个节点变成了另外一个节点,客户端直接将槽的请求发送给moved错误返回的节点
2. ask:两个节点正在进行槽的迁移时使用的临时措施,当客户端接收到ask错误后客户端只会在接下来的一次将槽i的请求转发至ask错误所指示的节点



## 复制和故障转移

1. 当集群中的某个master节点负责的槽宕机时,对应该节点的slave节点变为主节点(选举机制遵从raft算法)
2. 集群中的每个节点会定期向其他节点发送ping消息,正常则受到pong消息回复,如果没有在规定时间内收到pong消息则疑似下线,当大多数节点认为该节点疑似下线时,判定该节点疑似下线的节点会认为节点已下线,并通知其他节点将该节点更新为已下线从PFAIL变为FAIL
3. 故障转移
   - 当主节点宕机后,对应的从节点会选举出一个主节点
   - 被选为主节点的从节点执行slave no one操作,成为新的主节点
   - 将槽分配给自己
   - 集群中广播一条消息让其他master节点更新槽信息和节点信息
4. 选举主节点(遵从raft一致性算法)
   - 每个从节点都有成为主节点的选举机会
   - 选举开始时,当前任期号+1,在选举指定时间内超时重新选举任期号+1;一旦选举成功即接收到大多数节点的投票则成为主节点,给其他节点发送空的附加日志让其他节点变为跟随者;
   - 同时每个节点只能投一票,先到先得



## 消息

1. meet消息:节点添加到集群中握手成功消息
2. ping消息:集群中每个节点隔一段时间则会向其他节点发送ping消息来知道其他节点的状态
3. pong消息:当节点到发送这的meet消息和ping消息后给予回应
4. fail消息:当一个主节点判定另外一个主节点进入已下线状态时(主节点广播消息给其他节点,不接受gossip延迟)
5. publish消息:当节点接收到一个pushlish命令,节点会执行改命令同时向集群中其他节点进行广播一条publish消息,其他节点同时执行publish命令
6. 作用:比如更新槽对应的节点信息,节点的角色变化等