    
# 问题描述:
   - 寻找两个有序数组的中位数: https://leetcode-cn.com/problems/median-of-two-sorted-arrays/
    
# 思路:    
    public class Question004 {

    /**
     * 方案1:两个有序数组合并成一个数组
     * 标志位i和j,分别代表两个数组的遍历的下标  新数组temp
     * 如果 num1[i] > num2[j] 则将num2[j]放入新的数组中 j++
     *
     * @param nums1
     * @param nums2 2^n=32  n=log232
     * @return
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int i = 0, j = 0;
        int num1Length = nums1.length;
        int num2Length = nums2.length;
        int tempLength = num1Length + num2Length;
        int[] temp = new int[tempLength];
        int k = 0;
        // 两个数组都还未遍历完
        while (i < num1Length && j < num2Length) {
            if (nums1[i] <= nums2[j]) {
                temp[k++] = nums1[i];
                i++;
            } else {
                temp[k++] = nums2[j];
                j++;
            }
        }

        // 如果其中一个数组遍历完了,则将另外一个后面的数据追加写就行了
        if (i < num1Length) {
            // num1数组未遍历完成
            for (int l = i; l < num1Length; l++) {
                temp[k++] = nums1[l];
            }
        }

        if (j < num2Length) {
            // num2数组未遍历完成
            for (int l = j; l < num2Length; l++) {
                temp[k++] = nums2[l];
            }
        }

        // 求中位数
        if (tempLength % 2 == 0) {
            // 偶数 10
            // 0 1 2 3   1 2
            int second = tempLength / 2;
            int first = second - 1;

            return (double) (temp[first] + temp[second]) / 2;
        } else {
            // 0 1 2 3 4  (5+1)/2 -1  = 5/2-1
            return ((double) temp[tempLength / 2]);
        }
    }

    @Test
    public void test1() {
        int[] nums1 = {1, 2};
        int[] nums2 = {1, 3, 4, 5};
        System.out.println(findMedianSortedArrays2(nums1, nums2));
    }

    /**
     * 思路:
     * 求两个数组中中位数的时候,数为奇数即 (m+n+1)/2  数位偶数的时候 (m+n+1)/2和(m+n+2)/n
     * 由于当数是奇数的时候(m+n+2)/2=(m+n+1)/2 所以我们只用考虑偶数即  ((m+n+1)/2和(m+n+2)/n)/2.0即中位数的值
     * <p>
     * 函数:我们在两个数组中找第k大的元素
     * 1.k不在num1中  直接求num2中第k个元素
     * 2.k不在num2中  直接求num1中第k个元素
     * 3.k=1         相当于求num1和num2中最小的元素
     * <p>
     * 4.当k分别在num1和num2中时,分别求两个区间中k/2的元素 如果超过长度范围及integer.maxValue
     * 5.比较两个区间k/2中的元素值,如果num1小即k肯定不在num1的前k/2上 区间淘汰
     *
     * @param nums1
     * @param nums2
     * @return
     */
    public double findMedianSortedArrays2(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int left = (m + n + 1) / 2;
        int right = (m + n + 2) / 2;
        // 分别找两个k元素
        return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2;
    }

    /**
     * i:第一个数组的下标 j:第二个数组的下标
     *
     * @param nums1
     * @param i
     * @param nums2
     * @param j
     * @param k
     * @return
     */
    private double findKth(int[] nums1, int i, int[] nums2, int j, int k) {
        // k元素是否不在其中一个数组中
        if (i >= nums1.length) {
            // k不在num1中
            return nums2[j + k - 1];
        }
        if (j >= nums2.length) {
            return nums1[i + k - 1];
        }

        // 当k==1时即求两个数组中最小的
        if (k == 1) {
            return Math.min(nums1[i], nums2[j]);
        }

        // 分别找两个区间k/2的元素
        int num1Mid = (i + k / 2 - 1) < nums1.length ? nums1[(i + k / 2 - 1)] : Integer.MAX_VALUE;
        int num2Mid = (j + k / 2 - 1) < nums2.length ? nums2[(j + k / 2 - 1)] : Integer.MAX_VALUE;
        if (num1Mid < num2Mid) {
            // k肯定不在num1前面的k/2个元素中
            return findKth(nums1, i + k / 2, nums2, j, k - k / 2);
        } else {
            return findKth(nums1, i, nums2, j + k / 2, k - k / 2);
        }
    }
    }
