    
# 问题描述:
   - 缺失数字 https://leetcode-cn.com/problems/missing-number
    
# 思路:    
    public class Question268 {

    /**
     * 将n个数放入到bitset中,然后遍历从小到大的结果判断在bitset中是否存在
     *
     * @param nums
     * @return
     */
    public int missingNumber(int[] nums) {
        BitSet bitSet = new BitSet();
        for (int num : nums) {
            bitSet.set(num);
        }

        for (int i = 0; i < nums.length; i++) {
            if (!bitSet.get(i)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 异或的方式  a^b^b=a  如果某个数不存在则和的结果是该数
     *
     * @param nums
     * @return
     */
    public int missingNumber2(int[] nums) {
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum ^= nums[i] ^ (i + 1);
        }
        return sum;
    }

    /**
     * 自定义bitMap方式 比如bitMap每个区间未64    1/64=0 1%64=1  则该数在a[0][1]位置存储
     * <p>
     * 如果数位n即在 a[n>>6][n&0x40]
     *
     * @param nums
     * @return
     */
    public int missingNumber3(int[] nums) {
        int[] bitMap = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            // 元素在bitMap中下标
            int index = nums[i] / 64;
            // 元素在bitMap下标中对应的bit
            int location = nums[i] % 64;
            bitMap[index] |= 1 << location;
        }
        return -1;
    }

    @Test
    public void test1() {
        int[] nums = {3, 0, 1, 4, 2, 6};
        System.out.println(missingNumber3(nums));

        System.out.println(127 % 64);
    }
}
