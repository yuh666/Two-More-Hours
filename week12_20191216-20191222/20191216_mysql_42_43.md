## join

```sql
create table a(f1 int, f2 int, index(f1))engine=innodb;
create table b(f1 int, f2 int)engine=innodb;
insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);
insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);
```

```sql
select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2);
-- 分析sql:a:驱动表  b:被驱动表  返回行数:6行
extra:Block nested loop join :加载驱动表到join buffer(a过大则临时文件),b逐行扫描跟join buffer比较,满足条件的行加入到结果集中.当表b扫描后完对表a未扫描的行加入到结果集,同时b的字段为null
```

```sql
select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/
-- 当left join有where优化器会优化成join操作,由于表a中f1字段又索引此时
驱动表:b 被驱动表:a
extra:Index nested loop join:扫描表b一行记录取表b中f1字段到a表f1普通索引查询
```

1. 总结:当使用left join时不能有where操作,不然优化为join 
2. 当使用join操作是添加写在on和where一样
3. join操作优化器会优化来选择合适的驱动表和被驱动表

## distinct和group by

```sql
select a from t group by a order by null;
select distinct a from t;
```

1. 此时两个sql执行性能一样,但是group by 一般是结合聚合函数
2. group by 执行流程,1.创建临时表包括字段a,在a上创建唯一索引,取表a中每一行记录中a插入到临时表中,判断a是否存在,不存在则计数1存在则加1
3. 最后返回临时表执行结果;当不执行聚合函数时distance和group by性能一样

## slaver binlog id_auto

1. 自增id在同步给从库时,此时要选择binlog为row模式在binlog中会记录主库插入数据的auto_increment_id值;如果为statement时记录的为dml语句可能由于执行先后顺序影响id和主库不一致

## 自增id

1. int长度为4个字节 一个字节8bit  对应长度为32位  如果有符号则区间未 -2^31-2^31-1 无符号则:2^32-1
2. 当不使用自增id时则使用系统的rowId,rowId是全局的,所有无主键的表共享这个id.代码中实现是8字节的无符号,我们在设计时给row_id为6个字节;从0到2^48-1.rowId写入到最大后则在从0开始,这样会覆盖之前的数据