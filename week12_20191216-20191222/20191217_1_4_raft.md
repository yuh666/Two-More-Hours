## 强领导者

1. 与其他一致性算法不一样,raft使用的是强领导者;只会决策一次来选择leader,之后的比如日志同步通过leader来发送数据给follower,这样简化了日志管理的步骤
2. paxos算法使用的是多次决策,比如日志的复制;每一条日志都会去决策出leader然后是否发送数据;每一条日志都需要去决策

## 领导选举

1. raft算法在一致性算法保证心跳的基础上加了随机时间;比如当前有A B C三个节点A节点为leader,B和C节点为follower;leader和follower之间会发送心跳,每个follower都会有一个随机时间300-500ms,在随机这个时间内如果leader给follower发送了心跳则follower认为leader未宕机.这样可以避免当A节点宕机时,不会有多个B和C follower节点同时变为选举节点即节点状态变为candidater

## 成员关系调整

1. 采用共同一致的方法来处理集群成员变换的问题,处于调整过程中两种不同的配置集群中大多数机器会有重叠,湿的集群在成员变化的过程中依然可以工作

## 一致性算法特性

1. 安全性保证:无论在网络延迟 分区 丢包 冗余和乱序等情况下返回数据一定是正确的结果
2. 可用性:当集群中大多数节点活着时能相互之间通信时,服务能正常的被请求,当宕机节点恢复时能重新加入到机器中
3. 不依赖时序一致性:即物理时钟错误或者消息延迟只有在最坏情况下才会导致可用性问题
4. 一条指令可能快在集群中大多数节点响应完成远程调用过程,小部分比较慢节点不影响系统整理性能

## raft写数据

1. 首先当集群中三台机器ABC启动后,此时三台节点都为follower.此时会有一个节点变为candidater,往其他follower节点发送信号,当大多数节点同意时此时candidater节点为leader节点
2. 假设A:leader B.C:follower,当客户端给服务端写数据时,此时会写入到leader的log日志中此时标记为未提交;leader会向B C发送日志数据,follower检查当前日志数据和自己存在数据的偏移量后,发现leader发送过程数据未漏掉则直接写入到自己log中标记为未提交;如果发现leader偏移量大了,有一部分数据未发送过程,此时follower会向leader请求让leader从该偏移量开始发送数据.当leader回来心跳大多数follower写完log后,此时log数据变为提交,同时leader向客户端响应数据写入完成,同时leader会给follower发送数据提交信号,follower写入自己的副本中

## paxos算法问题

1. 单决策的缺点,每条数据都需要去决策,多决策
2. 理解复杂,paxos算法的理解和实现有很大的鸿沟很难去实现多决策有很多漏洞不健壮