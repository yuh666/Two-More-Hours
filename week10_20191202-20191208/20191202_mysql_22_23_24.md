## 短连接风暴

1. 场景:当数据库处理很慢时,连接会暴涨,会提示 too many connection

2. 配置:max_connections

   ```sql
   show VARIABLES like "%max_connection%"
   ```

3. 解决方案

   - 处理占用连接不工作的线程

     ```sql
     show processlist; -- 查看sleep对应的线程
     SELECT trx_id,trx_mysql_thread_id from INNODB_TRX -- kill connection thread-id
     ```

   - 减少连接过程的消耗
     当出现短时间需要申请大量的连接时,此时可以去掉连接器的权限验证,通过–skip-grant-tables

## 慢查询

1. 索引设计不合理:通过alter table添加索引,添加完索引可通过show index from t查看
   添加索引的过程5.6之后支持online
   1.MDL写锁 2.降级为MDL读锁 3.DDL 4.升级为MDL写锁 5.释放MDL写锁
2. sql编写问题
   通过explain解析sql
   查看type: const > eq_ref > ref > range >index > all
   查看rows:扫描的行数,可以通过慢日志查询查看slow_log表
   查看extra:using index:覆盖索引查询 using index condition:回表查询 using where:条件筛选
3. 优化器选错索引
   1.由于优化器中表数据问题,可以通过alter table engine = innodb,在查询sql
   2.通过force index指定索引名称

## QPS突增

1. 可能由于新服务的上线,或者突然情况到值mysql表锁比如更新语句条件未添加索引,导致整个表行锁+间隙锁
2. 停用该服务对应的账号,将qps降为0但是会出现业务失败
3. 将复杂的sql转为select 1
4. 通过监控定期处理慢sql查询进行优化,分开配置账号和权限

## 保证数据不丢失

1. redo log
   - redo log作用:记录已提交事物的数据,当数据库宕机时通过redo log恢复到脏页中刷新到磁盘,write到checkpoint记录当前写入的数据,redo log可重复利用写入到ibdata中
   - 两阶段提交,保证数据的完整性,防止主从数据不一致
   - redo log先写入到redo log buffer中,当执行器第一次提交时 redo log buffer write 到os cache中,在fsync到磁盘,可以通过innodb_flush_log_at_trx_commit设置
     1. 0:每次事物提交只是把redo log写入到redo log buffer中
     2. 1:每次事物提交redo log刷新到磁盘
     3. 2:每次事物提交redo log刷新到os cache中
2. binlog
   - binlog作用:归档日志,保存在server层,用来主从同步使用,记录物理日志和事物id
   - 当存储引擎返回给server层事物可以随时提交时,保存binlog日志,binlog cache write os cache,fsync os
   - 通过sync_binlog控制
     1. sync_binlog=0,表示每次事物提交只write不fsync
     2. sync_binlog=1,表示每次事物提交write fsync
     3. sync_binlog=N (N.1),表示每次事物提交write,当write事物超过n个时fsync

## 主备

1. 主备原理
   - 比如节点 A:master B:slaver(readonly) 配置从节点只读,主节点读写
   - 主从同步流程:
     1. 主库 start->undo log(mem)->data(mem)->redo log prepare->binlog->redo log commit->ack
     2. 在binlog写入后,dump thread(跟备库建立连接的线程)
     3. 备库上io thread和主库建立连接,备库通过change master命令告诉主库需要从binlog哪个position开始拉去数据
     4. 备库拿到binlog日志后写入到本地文件,relay log(中转日志)
     5. 备库sql thread 读取中转日志解析日志中的命令并执行
2. binlog三种方式
   - row:存储事物操作前后的数据结果集即物理日志
   - statement:存储事物操作前后的DML语句,逻辑日志(可能出现主从同步不一致性问题)
   - mixed:在存储binlog时会预先考虑到DML语句是否会影响结果不一致,会则row不会则statement
3. 双master
   - 两个节点都为master节点,其中一个只读,两个master之间数据双向同步
   - 由于binlog中保存当了binlog产生的server id用来标识是那一个master节点的binlog,如果和自己的master节点server id相同则不同步;比如ABmaster,B(readonly),当往A库中写入数据是此时B获取到binlog日志和自己server_id不等则写入binlog数据到B库,B库写完后会产生binlog同步给A库,A库发现server_id一致则不同步
   - 如何避免出现循环复制情况:比如三个节点,ABC,A->B B->C C->B当A同步数据过去是BC会出现循环同步问题