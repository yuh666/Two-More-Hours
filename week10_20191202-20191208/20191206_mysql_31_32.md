## Index Nested-Loop Join

```sql
CREATE TABLE `t2` 
( `id` int(11) NOT NULL, 
 `a` int(11) DEFAULT NULL,
 `b` int(11) DEFAULT NULL,
 PRIMARY KEY (`id`),
 KEY `a` (`a`)) ENGINE=InnoDB;
 create table t2 like t1;
```

```sql
select * from t1 straight_join t2 on t1.a = t2.a
```

1. straiht_join:mysql不走优化器指定的驱动表和被驱动表,此时t1:驱动表 t2:被驱动表
2. sql执行流程
   - 从t1表取一行记录,获取行记录中的字段a
   - 根据字段a,在t2表的普通索引上查询,找到满足条件数据,获取二级索引对应的t2.id
   - 根据t2.id回表查询t2行记录,返回结果集
   - 重复1-3步骤
3. 如果t1和t2对应的数据都是100行,数据等值即t1.a和t2.a一一对应
4. T1:全表扫描100行,t2:每次通过t1.a,在t2.a索引上找到t2.id,回表查询;t2:总共扫描100行
5. 假设驱动表数据量:N 被驱动表:M   则整个过程时间复杂度近似 N+N*2lgM   2:代表t2.a和t2.id两棵树
6. 显然N对时间复杂度影响较大,此时join需要小表来驱动大表

## Simple Nested-Loop join

```sql
select * from t1 straight_join t2 on t1.a = t2.b
当t2.b上没有索引时,此时需要进行全表扫描,此时扫描行数为N*M,不过mysql进行了优化为BNL
```



## Block Nested-Loop join

1. 首先将t1表数据读到join buffer中
2. 扫描表t2,把t2表中每一行数据和内存中t1表进行比较,将满足条件的作为结果即返回
3. 扫描行数:N+M  比较次数:M*N
4. 如果join buffer不够使用,t1表需要被拆分成多次放入join buffer,假设拆分为k次,k(0,1)
5. 此时扫描行数:N+kN*M 比较次数:N*M  当N越大的时候,被拆分的越多k则越大
6. 所以当小表为驱动表时,拆分后的k越小则扫描行数越少

## 总结

1. 是否使用join来查询?
   - 使用,如果分开为两次查询,扫描行数一样  但是sql的执行次数变
2. 选择小表作为驱动表还是大表作为驱动表?
   - 当join buffer足够大时(能一次加载驱动表到内存中时),结果一样
   - 当join buffer不够使用,需要拆分为多次加载驱动表时,选择小表为驱动表;
3. 小表为驱动表的好出?
   - 减少表的扫描行数,降低磁盘cpu
   - 当为BNL时,驱动表较大且为冷数据时,会导致LRU缓存中数据都是冷数据,因为两次查询间隔一秒后加入到LRU young区
4. 什么叫做小表?
   - 满足条件的行越小,相同条件满足的行放入到join buffer字段数越少越小

## MMR 优化

```sql
select * from t1 where t1.a >=50 and t1.a <=100
```

1. MMR优化首先将a索引满足条件对的id,先加载到read_rnd_buffer表
2. read_rnd_buffer对id进行排序
3. 读取磁盘上行数据,将随机读变为顺序读
4. 特点:区间查询,可以先得到满足条件的值排完顺序后回表查询

## Batched Key Access

```sql
select * from t1 straight_join t2 on t1.a = t2.a
```

1. 由于 index Nested-Loop join中每次都需要读取一行数据去t2表中查询,t2回表后返回数据,并没有使用join buffer
2. BKA首先将t1表中满足条件的行数据加入到join buffer中,从join buffer中取数据查询t2表

## BNL优化

1. 当join buffer不够使用时,可能多次扫描被驱动表,占用磁盘io

2. 判断join需要执行M*N比较,当数据量较大的时候,会占用非常多的cpu资源

3. 可能会导致buffer pool的热数据失效,影响内存命中率

4. 将BNL转为BKA执行,比如在连表字段上加索引,通过临时表的方式减少比较次数

   ```sql
   select * from t1 join t2 on (t1.b=t2.b) where t2.b>=1 and t2.b<=2000;
   1.先将t2表中满足条件的数据,存储到临时表中
   2.临时表对应的b字段加索引,t1来关联temp表
   ```

   