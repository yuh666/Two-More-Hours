## aof持久化

## appendonly.aof文件的格式

1. aof文件中存储客户端直接请求过来的命令文本格式
2. 当服务器重启时,加载aof文件中命令创建伪客户端来调用服务端执行命令载入aof文件到内存中



## aof持久化实现

1. 命令追加
   - 当开启appendonly yes之后,当服务端接收客户端的命令时会将命令追加到redisserver的aof_buf内存区域中(即多个redisdb共用一个aof文件)
2. 文件写入
   - 将aof_buf中的数据写入到磁盘的os cache中,因为操作系统的磁盘在写入数据到磁盘文件时是先写入到cache中,当cache中数据某个内存缓存区的空间被填满后将缓存区中的数据刷新到磁盘中,操作系统提供fsync和fdatasync可强制将缓存区中的数据写入到磁盘中,来保证数据的安全性
3. 文件同步
   - 将磁盘os cache中的数据刷新到aof文件中
   - appendfsync配置aof写入到os cache中的数据什么时候刷新到磁盘的aof文件中
     - always:每次写入数据的同时执行fsync操作刷新到磁盘aof文件
     - everysec:每次写入数据到os cache中,如果上次同步aof文件的时间到现在有一秒则刷新数据到磁盘中
     - no:等待操作系统来刷新数据到磁盘中,相比everysec将其多次操作合成了一次刷新操作这样执行时间其实等价,但是no更多会丢失最多的数据,所以一般追求性能的同步保证数据不丢失选择everysec(默认)



## aof文件载入与数据还原

1. 当服务器启动时,如果开启了aof的配置,会载入appendonly.aof文件到内存中
2. 创建一个伪客户端(相比客户端而已不需要来进行网络io通信)
3. 读取aof文件中每一行,通过伪客户端来调用服务端执行命令
4. 当aof文件写完之后则载入数据完成



## aof文件重写

1. 因为aof文件存储的是客户端的每一个操作命令,无论是查询删除还是set等;随着操作指令的变多aof文件则会写满需要进行rewrite操作(重写:不是指对旧aof文件重写是生成一个新的aof文件来替换)
2. 重写执行流程
   - fork一个子进程,创建一个新的aof文件
   - 遍历redisserver中的db数组,执行select操作切换db,遍历redisdb中存储数据的字典hash表,判断key是否过期,过期则执行下一个key,未过期则判断键对应的值的type类型(比如string list set hash zset),根据不同的类型将数据组装成对应的set语句比如hset user name boy age 18,同时判断key在db中的过期字典是否有过期时间有则写入过期时间,直到所有的db和key写完为止
   - 子进程进行重写操作同时,主进程接收客户端的请求将命令追加到aof_buf同时追加一份数据到重写aof_buf中(即原操作保证不变的同时,将rewrite操作过程中命令写入到重写aof_buf中,保证数据不丢失)
   - 当子进程写完新的aof文件之后,通知主进程aof文件写入完毕.此时不对外提供服务,将重新aof_buf中的数据写入和同步到新的aof文件中,然后替换旧的aof文件同时清空aof_buf完成重写操作,主进程继续对外提供服务

