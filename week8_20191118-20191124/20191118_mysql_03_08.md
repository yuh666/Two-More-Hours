## 1.事物的隔离性

1. 事物的ACID,原子性 一致性 隔离性 持久性
2. 隔离性:两个事物之间的操作是相互隔离的

## 2事物隔离级别

1. 事物的隔离级别,读未提交,读已提交,读可重复读,串行化,存在相关问题 脏读,不可重复读,幻读
2. 读未提交:一个事物可以读取到另外一个事物未提交的数据
3. 读已提交:一个事物只能读取到另外一个事物已提交的数据
4. 读不可重复读:当前事物在产生第一个read view视图后,每次读取到的结果一样
5. 串行化:加锁,写:写锁 读:读锁

## 3.事物隔离性实现的原理

1. mvcc多版本控制
   1. 当开启一个新的事物的时候,如果是update操作,每次会在之前的版本上copy一份新的版本,然后进行数据的修改,数据是存储在undo log中.如果是读操作读对应的版本数据
   2. 比如原始数据 k:1 V1  事物A: k+2  k=3  V2 事物B:k*10 k=30 V3
   3. 经过步骤2之后可以看到最新版本为V3,对一条数据只会存储一个版本的数据到数据库中,如果其他事物读取时要读取自己事物对应的版本,比如读取V1  此时通过V3->V2->V1 根据undo log
2. 快照读
   1. 事物进行read view操作时,获取活跃事物的id对应的数组,活跃(即开启事物,未提交的事物),数组中最小的即低水位
   2. 获取当前已提交事物id的最大值,最大值+1即高水位
   3. 在低水位之前的数据可见;在低和高之间的数据,如果在数组中存在不可见,不存在:可见;大于高水平,不可见
   4. 结论:
      1. 版本未提交不可见
      2. 版本已提交,如果在当前read-view之前可见,之后不可见
   5. 原理图
      ![image-20191118183630622](./../..//小霸王/image/msql_mvcc.png)
3. 当前读
   如果当前版本和当前事物id相等则为当前读

## 4.RC和RR的快照读区别

1. RC下每次都会创建一个新的read-view视图
2. RR下只会创建一个read-view,在当前事物第一次读的时候