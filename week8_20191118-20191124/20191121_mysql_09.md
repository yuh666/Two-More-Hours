### 1.查询过程

1. 普通索引
   - 根据当前值在普通索引的btree中找到对应的值相等的位置,筛选到最后一个不相等的值;将所有的主键id在内存中排序后读取数据页中数据
2. 唯一索引
   - 各级当前值在唯一索引的btree中找到值相等的叶子节点id,不需要继续往下查找因为唯一索引的数据只有一条.然后在根据主键id读取主键索引上的行数据
3. 差别
   - 普通索引对比唯一索引的查询多一次btree数的筛选工作,要找到下一个不相等的值.相差可以忽略因为不需要进行磁盘读都是索引树上查找.即两者查询效率相等

### 2.更新过程

1. 普通索引
   - 根据普通索引更新数据时,先判断当前数据对应的页是否在内存中存在,不存在则加入到change buffer中;当当前数据被查询的时候,获取数据页上数据然后跟change buffer进行merge后返回数据
   - 如果当前页在内存中,更新内存中数据
2. 唯一索引
   - 当唯一索引数据插入时,此时需要先校验唯一索引的正确性;如果当前页不在内存中,则需要读取页数据到内存中,判断索引是否重复.不重复则插入到内存页中
   - 当当前页在内存中,不重复则插入到内存页中
3. 差别
   - 唯一索引,当内存中不存在当前页数据时,还需要进行磁盘的读io操作,使用不了change buffer;普通索引当内存中不存在当前页的时候,不需要进行磁盘的读操作
4. change buffer适合的场景
   - 非唯一索引,写入读少的场景(写后不立刻读),比如对账数据 日志等,建议使用非唯一索引来降低磁盘的io读操作
     
     

### 3.redo log 和 change buffer

1. ```sql
   insert into user(name,age) values(张三,18),(王五,20)
   ```

   1. 假设张三对应页(page1)的普通索引在内存中存在,王五对应页(page2)在内存中不存在
   2. 张三:page1插入到内存中page1数据页;王五:page2 添加到change buffer中
   3. add 张三 page1; add change buffer 王五 page2;两条sql写入到redo log中
   4. ![image-20191121152820028](https://note.youdao.com/yws/api/personal/file/WEB96ee0ed239d83862741f6c6eabd01f44?method=download&shareKey=32edabf97659582b73714bf29d85eb97)
   5. 结论:change buffer降低了随机读磁盘的io操作;redo log让多个redo log的写操作变为顺序写,
      redo log中的数据刷新到磁盘还是随机写

### 4.问题

1. change buffer先是写入到内存中,如果这个时候数据库宕机,恢复后是否会丢失数据?
   - 写数据的操作流程
     - 1.写入change buffer
     - 2.写入redo log 此时redo log prepare commit
     - 3.写入binlog
     - 4.redo log commit
   - 数据不会丢失,因为change buffer的数据写入到redo log中
2. merge的流程
   - 从磁盘读取页的数据到内存中(旧版本的数据)
   - 从change buffer中找出这些页数据的change buffer记录(可能存在多个记录),依次执行后得到最新的页数据
   - 写redo log(包括数据页的变更和change buffer的变更)