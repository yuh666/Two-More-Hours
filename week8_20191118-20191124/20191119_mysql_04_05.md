## 1.常见的索引模型

1. hash索引

   - 原理:key-value的方式存储,比如name:张三,通过hash后O(1)定位到数据
   - 存在问题:当多个数据hash得到的结果一样的时候,此时需要在hash对应的数组下方挂一个链表,查询和删除的时间复杂度增加;不适合范围内的数据查询
   - 适用场景:比如身份证号,永远不会重复的数据,进行数据的等值查询;在mysql中有自适应hash索引

2. 二叉搜索树

   - 原理:查询时间复杂度O(logn),左边节点小于当前节点,右边节点大于当前节点,通过中序遍历可以得到所有结果
   - 存在问题:当插入数据的时候,如果数据分配在单个左右节点,导致树的高度过长,浪费空间,查询效率不等
   - 使用场景:当数据较少,构建的二叉搜索树较均匀时

3. 二叉平衡树

   - 原理:在二叉搜索的树的基础上,保证叶子节点的高度差不超过1,当数据插入的时候进行左旋和右旋
   - 存在问题:当数据量较大的时候,高度也会很高,在数据存储时每一页读取的数据有限,需要进行大量的磁盘页读取操作
   - 使用场景:数据较少的时候

4. B树

   - 原理:在二叉平衡树的基础上降低树的高度,每个节点存储多个数组  比如 第一层:  [3,10]  第二层:左:[1,2]

     中间:[4,6,8]  右:[11,12,13]  降低了数的高度,此时叶子节点和非叶子节点都存储数据

   - 存在问题:非叶子节点存储了数据,导致查询的时候筛选出来的数据在叶子节点和非叶子节点都存在,不方便数据的筛选和查询

5. B+树

   - 原理:在B树的基础上将非叶子节点的数据下层,非叶子节点不存在数据,所有数据存储在叶子节点中,叶子节点数据通过链表相连.非叶子节点即向上抽取的索引区间,跟链表类似
   - 优点:降低了树的高度,进行搜索的时候方便数据定位O(logn)

### 2.Innodb聚集索引和普通索引,MyISAM索引

1. Innodb
   - 聚集索引:主键索引和行记录存在一起,主键索引选择:主键索引-->唯一不为空索引-->自动生成rowId
   - 普通索引:普通索引的B+树的叶子节点存储主键索引的id
   - 联合索引:最左原则,构建索引的节点右多个参数,依次比较后存储 比如 [1,1] [1,2] [2,1] [2,3] [3,1] [3,4]
2. MyISAM
   - 主键索引和行数据分开存储,主键索引和普通索引的叶子节点存储行记录的地址值

## 3.回表查询和覆盖查询

1. 回表查询:当通过普通索引来查询数据的时候,比如 3<=age<=5,第一步通过age=3在age对应的二叉搜索中搜索到[3,5,6]这个区间,先定位age=3数据的主键id=1,根据主键id=1去主键索引的b+树中获取行记录;第二步选择定位区间的5,根据5对应的主键id去查询行数据;第三次:取到6的时候不满足条件则循环结束;
2. 覆盖索引:当查询数据的时候,如果数据在普通索引中已经存在,则不需要根据主键去主键索引上定位行数据获取;
   比如联合索引(name,age) 查询 select name,age from user where name="张三";此时不需要回表查询;
3. 查看索引
   show index from 表;
   ![image-20191119164200193](https://note.youdao.com/yws/public/resource/4762addbbb207565dafe6a1264ea04a1/xmlnote/4C22AB4C51934182A62CA1CC60333D41/8705)
   - table:表名
   - non_unique: 0:代表唯一索引 1:非唯一索引
   - Key_name:索引名称
   - seq_in_index:索引在下标比如联合索引ca,c:1 a:2
   - column_name:字段的名称
   - collation:A:btree
   - Cardinality:随机从数据库中选择8条数据,不同的数据有几条  当为1时不适合建立索引
   - 注意事项:在mysql执行的过程中优化器可能选择不是自己想要的索引,可以在查询表后面指定索引force index(索引名称)

### 4.问题分析

1. 问题一

   - 进行 

     ```sql
     ALTER TABLE `test`.`geek` DROP INDEX `c`,ADD INDEX `c`(`c`) USING BTREE;
     ```

     ```sql
     ALTER TABLE `test`.`geek` DROP INDEX `id`,ADD INDEX `id`(`id`) USING BTREE;
     ```

   - 1.删除普通索引:正常操作

   - 2.删除主键索引,当删除主键索引的时候会导致所有的普通索引上的数据需要重构,增加额外的索引的空间

   - 3.操作修改存储引擎让索引数据被回收

     ```sql
     ALTER TABLE `test`.`geek` engine = Innodb;
     ```

2. 问题二

   - 当前数据中已经存在了c和(a,b)的索引,为啥还需要(c,a)和(c,b)

   - 数据库存在以下sql

     ```sql
     select * from geek where c=4 order by a
     ```

     ```sql
     select * from geek where c=4 order by b
     ```

   - (c,a)索引不需要存在,因为在普通索引c中如果c相同,对应的叶子节点会安装主键索引a进行排序,这样c相同的数据,已经按照a的顺序排好此联合索引可以去掉

   - (c,b)联合索引有必要,因为主键索引是(a,b),普通索引下c相同的叶子节点不会按照b来排序,此时需要b这样order by b的时候不需要二次排序