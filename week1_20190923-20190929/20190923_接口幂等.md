# 一 常见操作
 - select查询幂等
 - delete删除幂等
 - update进行复合操作非幂等(比如 update 表 set money=money-100)
 - insert语句非幂等

# 二 幂等场景
 - 网络问题,重复发送
 - 点击刷新按钮
 - 浏览器回退上一步
 - 服务框架重试,比如dubbo rpc重试等

# 三 解决方案
 - 前端解决方案忽略  
 - 数据库层面:
    - insert语句,唯一主键:每次插入操作获取插入意向锁(间隙锁中特殊情况),不同区间不影响,相同区间不同行不影响
    - update操作,乐观锁版本号,版本号使用时间戳的方式(最常用CAS原子性+版本号解决ABA问题),高并发非核心业务可以使用
    - 排他锁,在select时加上for update
 - 业务层面:
    - 对方法加synchronized,并发量较小的情况下使用
    - 本地内存锁:维护统一Map,每次请求的时候判断map中key是否存在(key通过请求参数md5生成),map中key维护一定的过期时间,作用比如用户购买相同商品本质请求参数相同但又不是重复请求,此时需要定时任务去定期清理map中key即维护key会过期的map
    - redis分布式锁或者zk:每个请求生成唯一的UUID设置对应的过期时间,通过redis setIfAbsent来判断key是否存在,存在即重复提交,否则执行业务
 
# 四 本地内存实现

              
    @Target(value = ElementType.METHOD)
    @Retention(value = RetentionPolicy.RUNTIME)
    @Documented
    public @interface Resubmit {
        /**
         * 延时时间
         *
         * @return
         */
        int delaySeconds() default 20;
    }
   
   - 
    @Component
    @Aspect
    @Order(20)
    public class ResubmitGlobalHandler {

    private static final Object VALUE = new Object();

    @Pointcut(value = "@annotation(com.github.zhouzhihui.esshop.inventory.biz.annotation.Resubmit)")
    public void matchResubmit() {

    }

    @Around(value = "matchResubmit()")
    public CommonResponse around(ProceedingJoinPoint joinPoint) {
        Method method = ((MethodSignature) joinPoint.getSignature()).getMethod();
        Resubmit resubmit = method.getAnnotation(Resubmit.class);
        int delaySeconds = resubmit.delaySeconds();

        Object[] args = joinPoint.getArgs();
        Object firstParam = args[0];
        if (firstParam instanceof CommonRequest) {
            Object reqData = ((CommonRequest) firstParam).getReqData();
            Map map = JSON.parseObject(JSON.toJSONString(reqData), Map.class);
            StringBuilder builder = new StringBuilder();
            map.forEach((key, value) -> builder.append(value));

            // 计算key
            String key = ResubmitLock.handlerKey(builder.toString());

            ResubmitLock resubmitLock = ResubmitLock.getInstance();
            boolean lock = false;
            try {
                // 加锁
                lock = resubmitLock.lock(key, VALUE);
                if (lock) {
                    // 获取锁成功,执行业务逻辑
                    try {
                        return ((CommonResponse) joinPoint.proceed());
                    } catch (Throwable throwable) {
                        throwable.printStackTrace();
                    }
                } else {
                    // 获取锁失败即重复提交
                    return new CommonResponse("50000000", "重复提交");
                }
            } finally {
                // 指定时间释放锁
                resubmitLock.unlock(lock, key, delaySeconds);
            }
        }
        return new CommonResponse(ErrorCodeEnum.SUCCESS.getResCode(), ErrorCodeEnum.SUCCESS.getResMessage());
    }
    }
    
-
    
    public class ResubmitLock {

    /**
     * 本地缓存
     */
    private static final ConcurrentHashMap<String, Object> LOCK_CACHE = new ConcurrentHashMap<>();

    private static final ScheduledExecutorService EXECUTOR_SERVICE = Executors.newScheduledThreadPool(10);

    public static class SingleTon {

        private static ResubmitLock resubmitLock;

        static {
            resubmitLock = new ResubmitLock();
        }

        public static ResubmitLock getInstance() {
            return resubmitLock;
        }
    }

    public static ResubmitLock getInstance() {
        return SingleTon.getInstance();
    }

    /**
     * 处理key
     *
     * @param key
     * @return
     */
    public static String handlerKey(String key) {
        return key == null ? "" : DigestUtils.md5DigestAsHex(key.getBytes());
    }

    /**
     * 获取锁 true:成功 false:失败
     *
     * @param key
     * @param value
     * @return
     */
    public static boolean lock(String key, Object value) {
        return Objects.isNull(LOCK_CACHE.putIfAbsent(key, value));
    }

    /**
     * 解锁
     *
     * @param lock         是否需要解锁
     * @param key          key
     * @param delaySeconds 延迟时间
     */
    public static void unlock(boolean lock, String key, int delaySeconds) {
        if (lock) {
            EXECUTOR_SERVICE.schedule(() -> {
                LOCK_CACHE.remove(key);
            }, delaySeconds, TimeUnit.SECONDS);
        }
    }
}




