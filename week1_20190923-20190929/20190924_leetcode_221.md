# 描述:
     在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
     示例:
     输入:
     1 0 1 0 0
     1 0 1 1 1
     1 1 1 1 1
     1 0 0 1 0
     输出: 4
     来源：力扣（LeetCode）
     链接：https://leetcode-cn.com/problems/maximal-square
     著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 
# 方案一:暴力法
    /**
     * 暴力解法:
     * 1.从左上角开始遍历元素,如果元素等于1 则以当前元素为基础,向下和向右指定基础步长1(向下和向右下标需在行和列范围中)
     * 2.向下和向右遍历的过程中记录标记位当其中一个为0时退出循环 记录当前步长数即最大正方形
     *
     * @param matrix
     * @return
     */
    public int maximalSquare(char[][] matrix) {
        int row = matrix.length;
        int col = row > 0 ? matrix[0].length : 0;
        int maxLength = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == '1') {
                    int stepLength = 1;
                    boolean flag = true;
                    while (i + stepLength < row && j + stepLength < col && flag) {
                        // 向下
                        for (int r = i; r <= stepLength + i; r++) {
                            if (matrix[r][j + stepLength] == '0') {
                                flag = false;
                                break;
                            }
                        }

                        if (!flag) {
                            break;
                        }
                        // 向右
                        for (int c = j; c <= stepLength + j; c++) {
                            if (matrix[i + stepLength][c] == '0') {
                                flag = false;
                                break;
                            }
                        }

                        // 如果指定步长遍历都满足则步长+1
                        if (flag) {
                            stepLength++;
                        }
                    }
                    if (stepLength > maxLength) {
                        maxLength = stepLength;
                    }
                }
            }
        }
        return maxLength * maxLength;
    }

# 方案二:动态规划
    /**
     * 1 0 1 0 0
     * 1 0 1 1 1
     * 1 1 1 1 1
     * 1 0 0 1 0
     * <p>
     * 0 0 0 0 0 0
     * 0 1 0 1 0 0
     * 0 1 0 1 1 1
     * 0 1 1 1 2 2
     * 0 1 0 0 1 0
     * 动态规划:
     * 1.初始化一个新的矩阵dp和元矩阵一样,初始化值为0
     * 2.从左上方遍历,当元素为1时,更新值 dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1[j-1])+1
     * 3.通过一个变量记录maxLength即dp[i][j]最大值
     *
     * @param matrix
     * @return
     */
    public int maximalSquare2(char[][] matrix) {
        int row = matrix.length;
        int col = row > 0 ? matrix[0].length : 0;
        int maxLength = 0;
        // 矩阵统计长度+1
        int[][] dp = new int[row + 1][col + 1];

        for (int i = 1; i <= row; i++) {
            for (int j = 1; j <= col; j++) {
                // 重左上方开始 当值为1则计算dp值
                if (matrix[i - 1][j - 1] == '1') {
                    // 矩阵中最小值+1
                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;
                    // 记录长度
                    maxLength = Math.max(maxLength, dp[i][j]);
                }
            }
        }
        return maxLength * maxLength;
    }