# 描述:
     给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

    例如:
    给定二叉树: [3,9,20,null,null,15,7],
    
        3
       / \
      9  20
        /  \
       15   7
    返回其层次遍历结果：
    
    [
      [3],
      [9,20],
      [15,7]
    ]
    
    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 
# 方案
     /**
     * 二叉树node 节点
     */
    public class TreeNode {
        int      val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    /**
     * 层次遍历:
     * 1.将root节点放入一个队列中Queue originQueue
     * 2.判断队列是否为空,为空终止
     * 3.从originQueue中poll一个元素,放入currentLevelQueue中,判断originQueue是否为空,不为空继续讲originQueue中队列放入currentLevelQueue,这样currentLevelQueue装满当前层的所有节点
     * 4.当originQueue为空后,取当前层队列currentLevelQueue中节点,如果节点包含左右节点在放入originQueue即originQueue中存储下一次层元素
     * 5.每次在遍历currentLevelQueue中队列的元素时,将结果放入这一层的list中
     *
     * @param root
     * @return
     */
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new ArrayList<>(0);
        }
        // 存储每一层的node数据
        Queue<TreeNode> originQueue = new LinkedList<>();
        originQueue.offer(root);

        // 结果
        ArrayList<List<Integer>> result = new ArrayList<>();

        // 当前层数的元素
        Queue<TreeNode> currentLevelQueue = new LinkedList<>();

        while (!originQueue.isEmpty()) {
            // 当前层有元素
            TreeNode currentNode = originQueue.poll();
            currentLevelQueue.offer(currentNode);

            if (originQueue.isEmpty()) {
                // 当前层元素遍历完成,都放入currentLevelQueue队列
                // 每一层结果
                ArrayList<Integer> list = new ArrayList<>();
                while (!currentLevelQueue.isEmpty()) {
                    // 取当前层的元素放入结果集
                    TreeNode node = currentLevelQueue.poll();
                    list.add(node.val);
                    if (node.left != null) {
                        originQueue.offer(node.left);
                    }

                    if (node.right != null) {
                        originQueue.offer(node.right);
                    }
                }
                result.add(list);
            }
        }
        return result;
    }

    /**
     * [3,9,20,null,null,15,7],
     */
    @Test
    public void test1() {
        TreeNode root = new TreeNode(3);
        TreeNode left1 = new TreeNode(9);
        TreeNode right1 = new TreeNode(20);
        root.left = left1;
        root.right = right1;

        TreeNode left2 = new TreeNode(15);
        TreeNode right2 = new TreeNode(7);
        right1.left = left2;
        right1.right = right2;

        root = null;
        System.out.println(levelOrder(root));
    }