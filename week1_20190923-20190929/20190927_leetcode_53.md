# 描述 
    给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

    示例:
    
    输入: [-2,1,-3,4,-1,2,1,-5,4],
    输出: 6
    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
    
    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/maximum-subarray
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
       
# 方案
    public class Question053 {

    /**
     * 当 sum < 0 说明之前的子序列对后面的子序列是负数,说明最大子序列肯定没有当前元素之前的子序列
     * 当 sum >0  说明对后面的子序列是有增强作用即相加
     *
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int sum = 0;

        // 遍历当前num 当num >0时,与sum相加
        for (int num : nums) {
            // 之前最大子序列大于0
            if (sum > 0) {
                // 之前总和+当前值
                sum += num;
            } else {
                // 从当前值开始记录
                sum = num;
            }
            // 最大值即 之前总和和当前总和比较
            ans = Math.max(ans, sum);
        }
        return ans;
    }

    /**
     * 动态规划:  f(n) = Math.max(nums[n],f(n-1)+nums[n])
     * 当前最大子序数即 当之前子序数位负数时即 最大子序数为自己 nums[n]   ,如果当前子序数位
     * <p>
     * f(0)= nums[0]
     * f(1) = Math.max(nums[1],f(0)+nums[1])
     * <p>
     * 可通过临时 dp数组,i标识当前遍历元素下标
     * 当 dp[i-1] >=0时
     * dp[i]= dp[i-1]+nums[i]
     * 当 dp[i-1] <=0是
     * dp[i] = nums[i]
     *
     * @param nums
     * @return
     */
    public int maxSubArray2(int[] nums) {
        int length = nums.length;
        int[] dp = new int[length];
        dp[0] = nums[0];

        for (int i = 1; i < length; i++) {
            if (dp[i - 1] >= 0) {
                dp[i] = dp[i - 1] + nums[i];
            } else {
                dp[i] = nums[i];
            }
        }

        // 求dp中最大的值
        int max = dp[0];
        for (int i = 1; i < length; i++) {
            max = Math.max(max, dp[i]);
        }
        return max;
    }


    @Test
    public void test1() {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(maxSubArray(nums));
        int i = maxSubArray2(nums);
        System.out.println(i);
    }
}