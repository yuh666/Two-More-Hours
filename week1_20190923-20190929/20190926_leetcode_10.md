    public class Question010 {

    int sLength, pLength;

    public boolean isMatch(String s, String p) {
        sLength = s.length();
        pLength = p.length();
        return match(s, p, 0, 0);
    }

    /**
     * '.' 匹配任意单个字符
     * '*' 匹配零个或多个前面的那一个元素
     * <p>
     * match函数代表: i-sLength与j-pLength 匹配
     * <p>
     * 思路:
     * 递归终止条件:当 j==pLength,代表正则匹配串走完,此时i==sLength的结果true即匹配上false即失败
     * 如果: p[j+1] == *
     * 1.当 p[j]=. 或者 s[j]==p[j],两个字符串j位置相等,因为j+1位*,此时只需要match(i+1,j)或match(i,j+2)任意一个满足,则j和i匹配
     * 2.不满足则,match(i,j+2)
     * 当不为*时
     * p[j = . 或者 s[j]=p[j] match(i+1,j+1)
     *
     * @param s 待匹配串
     * @param p 正则串
     * @param i 当前s匹配元素下标i
     * @param j 当前p匹配元素下标j
     * @return 匹配:true 不匹配:false
     */
    private boolean match(String s, String p, int i, int j) {
        if (j == pLength) {
            return i == sLength;
        }

        if (j < pLength - 1 && p.charAt(j + 1) == '*') {
            // 当 p[j+1]=*时
            if (i < sLength && (p.charAt(j) == '.' || s.charAt(i) == p.charAt(j))) {
                // 当p[j] = .或者 s[i] = p[j]时
                return match(s, p, i + 1, j) || match(s, p, i, j + 2);
            }
            return match(s, p, i, j + 2);
        }

        if (i < sLength && (p.charAt(j) == '.' || s.charAt(i) == p.charAt(j))) {
            // 当p[j] = .或者 s[i] = p[j]时
            return match(s, p, i + 1, j + 1);
        }
        return false;
    }

    @Test
    public void test1() {
        System.out.println(isMatch("aa", "a*"));
    }
}