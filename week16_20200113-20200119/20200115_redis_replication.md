## 复制

## 旧版本的复制流程

1. 复制分为两部分同步(sync)和命令传播(command propagate)
2. 同步
   - 从服务向主服务器发送sync命令
   - 主服务器接收到命令后,进行bgsave生成rdb文件,同时记录生成过程中新的写入命令到缓存区
   - 主服务器bgsave完成之后,将rdb文件发送给从服务器,从服务器状态rdb文件,并将自己的数据库状态更新为主服务器执行bgsave命令时的数据库状态
   - 主服务器将记录缓存区中的所有写命令发送给从服务器,从服务器执行写命令,同时更新自己的状态为主服务器状态
3. 命令传播:当sync命令执行完成之后主从数据库的同步状态一致,此时主服务器接收新的命令后会导致主从数据不一致,所以需要命令的传播,传播流程如下
   - 客户端向主服务器发送一个命令
   - 主服务器将命令传播给从服务器
   - 从服务器执行命令完成数据的传播即保证主从数据一致性
4. 旧版本复制的缺陷:
   - 初次复制时:从服务器重来没有复制过任何主服务器,或者从服务器之前复制的主服务器和当前要复制的主服务器不一致时
   - 断线后重复制:处于命令传播阶段的主从服务器因为网络问题断开一段时间后,从服务器重新连接上来进行复制主服务器
   - 问题分析:如果是初次复制旧版本复制没问题,如果是断线后重复制,此时如果还执行sync命令,此时主服务器需要生成rdb文件,缓存区的所有写命令都发送给重服务器,这个过程中会存在重服务器已经有的数据,正确应该是主服务器只给重服务器发送增量的内容即从服务器宕机到现在内容
   - rdb文件生成:耗费主服务器的cpu 内存 磁盘io
   - 主服务将生成rdb文件和缓存区中写命令发送给从服务器,主从服务器都会有网络带宽和流量
   - 从服务器在载入rdb文件时,不能处理请求命令 会导致命令阻塞



## 新版本复制2.8之后

1. 通过psync命令来替代sync命令执行同步,包括两部分完整重同步(full resynchronization)和部分重同步(partial resynchronization),完全同步复制和之前sync复制一样,部分同步复制如下

2. 部分复制的三个部分

   - 主服务的复制偏移量(replication offset)和从服务的复制偏移量
     - 当主服务发送数据给从服务器后修改自己的偏移量:lastOffset+N(发送字节数)
     - 当从服务器接收到主服务器发送的数据后修改自己的偏移量

   - 主服务的复制积压缓冲区(replication backlog)
     - 维护一个FIFO先进先出的队列,用来保存最新的1M的数据,用来给从服务器进行偏移量的复制
     - 可以通过second*write_size_per_second来估算,second:从服务器断开后重新连接的平均时间单位s,write_size_per_second:主服务器每秒中写入数据的数,建议:2 * write_size_per_second根据repl-backlog-size修改复制积压缓冲区的大小
   - 服务器允许的id(40位的十六进制随机id)
     - 从服务器来记录当前从服务器跟随的主服务的机器id,用来判断从服务器复制的主服务器是否改变

3. 新版整个复制流程

   - 如果从服务器未同步过任何主服务器或者之前执行了slaveof no one命令,此时从服务器给主服务器发送PSYNC ? -1命令,主动请求主服务器进行完整重复制
   - 不满足第一步后,说明从服务器之前接收过主服务器的同步,发送PSYNC <runid> <offset>命令,runid:从之前同步的主服务器id,offset:从服务器的偏移量此时会对应不同结果如下
     - runid和主服务器的runid不一致,主服务返回 fullresync <runid> <offset>回复从服务器,执行完全重复制,从服务器保存runid和offset,用来下次进行部分复制使用
     - runnid相同,offset在主服务器对应的复制积压缓存区中不存在,同第一步执行fullresync <runid> <offset>
     - runnid相同,offset在主服务器对应的复制积压缓存区,主服务器回复+continue给从服务器执行部分同步,即主服务器发送offset到复制积压缓存区结束的位置的数据给从服务器,从服务器执行同步更新自己数据库状态与主服务器保持一致,之后进行命令的传播



## 复制的实现

1. 保存ip和端口号:当从服务器执行,slaveof <master_ip> <master_port>,首先从服务器将客户端给的master_ip和master_port保存到自己reidsServer对应的masterhost和masterport,然后返回客户端一个结果;复制过程是异步完成的

2. 建立套接字连接:从服务根据ip和port创建连向主服务器的套接字,如果从服务器创建的套接字连接成功则创建一个专门处理复制的文件事件处理器.负责后续复制工作和接收rdb文件,主服务器的传播指令;同时从服务器相当于与主服务器的客户端,主服务器在redisClient中保存该客户端的信息

3. 发送ping命令:从服务器给主服务器发送一个ping命令

   - 虽然建立了套接字连接,但是未进行任何通信,发送ping命令来检查套接字的读写状态是否正常
   - 因为在复制过程中需要套接子来进行数据的传输,发送ping命令将会有以下情况:
     - 主服务器向从服务器返回一个命令回复,但从服务器在timeout时间能不能解析处理即超时,说明主从之间的网络状态不正常,不能进行复制工作,此时从服务器需要断开后重新建立套接字
     - 主服务器给从服务器返回一个错误,即代表主服务器现在不能执行复制工作,当出现这种情况时,从服务器断开套接字重新建议连接.比如主服务器正在处理超时的脚本
     - 从服务器接收到主服务发送的pong指令即可以进行下一步复制工作

4. 身份验证:

   - 从服务器是否设置materauth,即从服务器发送auth 密码给主服务器( masterauth <master-password>)
   - 主服务器是否开启了requirepass,即主服务器是否校验从服务器发送过来的密码是否正确(requirepass foobared)
   - 结论:
     - 都没开启,验证通过
     - 主服务器开启,从未开启 认证失败
     - 主服务器未开启,从服务器开启 认证失败
     - 主服务器开启,从服务器开启 密码不同认证失败,相同成功

5. 发送端口信息

   - 身份验证通过后,从服务器执行replconf listening-port <port-number>向主服务器发送从服务器监听的端口号 比如 replconfg listening-port 12345 即从服务器的端口未12345

   - 主服务器将数据保存到从服务器作为客户端在主服务器中存储的redisclient的slave_listening_port上

     ```java
     127.0.0.1:6379> slaveof 192.168.62.25 6379
     OK
     
     127.0.0.1:6379> info replication
     # Replication
     role:master
     connected_slaves:1
     slave0:ip=172.17.0.1,port=6379,state=online,offset=220,lag=1
     master_replid:e5e6f7ddb1917702c4e5db78bca353690c4cbf60
     master_replid2:0000000000000000000000000000000000000000
     master_repl_offset:220
     second_repl_offset:-1
     repl_backlog_active:1
     repl_backlog_size:1048576
     repl_backlog_first_byte_offset:1
     repl_backlog_histlen:220
     ```

6. 同步

   - 从服务器向主服务器发送psync命令,执行同步操作,将自己数据库状态更新为主服务器数据库状态
   - 在同步之前,从服务器是主服务器的客户端,当同步时主服务器也是从服务器的客户端
     - 当执行psync命令执行完整重同步操作时,主服务器作为从服务器的客户端来保证缓存区中的所有写命令发送到从服务器中
     - 当执行psync命令执行部分重同步操作时,主服务器成为从服务器的客户端,才能将复制积压缓冲区中的写命令

7. 命令传播

   - 当完成完整重同步或者部分重同步工作后,主从服务器就会进入命令传播阶段,此时主从数据库状态一致,当主服务器接收命令时通过命令传播给从服务器来保证数据状态一致性

8. 心跳检查

   - 命令传播阶段,从服务器每秒一次频率向主服务发送命令:replconf ack <replication offset>

   - 检查主从服务器的网络连接状态:主服务器隔1s后没接收从服务器发送的心跳,则主从指间连接出现问题,通过info replication的lag可以查看时间单位秒

   - 辅助实现min-slaves配置选项:防止主服务器在不安全的情况下执行写命令

     ```java
     min-slaves-to-write 3
     min-slaves-max-lag 10
     当从服务器的个数小于3或者从服务器与主服务器指间心跳超过10s,主服务器不能写入数据
     ```

9. 检查命令丢失

   - 比如当主从部分复制时,主服务器发送积压复制缓冲区的数据给从服务器,主服务器更新了自己的offset但是从服务器接收到命令后执行失败此时从服务器未更新自己的offset
   - 每次从服务器发送offset过来时以从服务器发送的offset为准来发送数据,这样可以防止命令丢失