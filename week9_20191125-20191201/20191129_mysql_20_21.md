## 幻读

1. 两次相同的sql查询同一个区间时,返回的行数不同 即出现幻觉

2. 证明非所有字段查询时加锁情况

   ```sql
   CREATE TABLE `t` (
     `id` int(11) NOT NULL,
     `c` int(11) DEFAULT NULL,
     `d` int(11) DEFAULT NULL,
     PRIMARY KEY (`id`),
     KEY `c` (`c`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
   INSERT INTO `t`(`id`, `c`, `d`) VALUES (0, 0, 0);
   INSERT INTO `t`(`id`, `c`, `d`) VALUES (5, 5, 5);
   INSERT INTO `t`(`id`, `c`, `d`) VALUES (10, 10, 10);
   INSERT INTO `t`(`id`, `c`, `d`) VALUES (15, 15, 15);
   INSERT INTO `t`(`id`, `c`, `d`) VALUES (20, 20, 20);
   INSERT INTO `t`(`id`, `c`, `d`) VALUES (25, 25, 25);
   ```

   ```sql
   begin;
   select * from t where d=5 for update;
   ```

3. 此时是对d=5的所有行加行锁,所有的区间加间隙锁

4. 证明

   |      | session A                                                    | session B                     | session C                   |
   | ---- | :----------------------------------------------------------- | ----------------------------- | --------------------------- |
   | T1   | begin;<br />select * from t where d=5 for update;            |                               |                             |
   | T2   |                                                              | update t set d= 5 where id=0; |                             |
   | T3   |                                                              |                               | insert into t values(4,3,5) |
   | T4   | select * from where d=5 for update;<br />假设sessionb和sessionc都不阻塞<br />此时读到数据为<br />(0,0,5) (4,3,5) (5,5,5) |                               |                             |

   - session A当前读时产生了幻读,违背了session A将d=5的所有行锁住
   - 此时innodb是对应所有的行加行锁,区间加间隙锁
   - (-无穷,0] (0,5] (5,10]..... 左开右闭

## gap-lock

1. 间隙锁:锁定一个范围当时不包括本身,间隙锁之前不互斥

## record-lock

1. 记录锁:对某一行记录加锁

## next-key lock

1. 临界锁:对某个区间包括本身加锁即gap+record

## 锁分析思路

1. 原则1:加锁的基本单位为next-key lock,左开右闭
2. 原则2:查找中访问的对象才加锁
3. 优化1:索引上的等值查询,给唯一索引时,临界锁降级为行锁
4. 优化2:索引上的等值查询,向右遍历且最后一个值不满足等值条件时,锁降级为间隙锁
5. bug:唯一索引的范围查询,会访问到第一个不满足条件的位置
6. 注意事项:等值范围查询比如 >=时第一个值为=等值查询,>范围查询

### sql分析

1. 等值查询间隙锁

   ```sql
   begin;
   update t set d= d+1 where id=7;
   
   - 根据原则1,id=7在 (5,10]上next-key lock
   - id=7在数据库中不存在
   - 优化1不满足,优化2:等值查询,向右找到最后一个不满足的值为10,此时降级为间隙锁(5,10)
   ```

2. 非唯一锁等值锁

   ```sql
   begin;
   select id from t where c = 5 lock in share mode;
   ```

   - 根据原则1:普通索引c区间 (0,5]
   - :由于c=5是普通索引,需要向右遍历找到不相等为止,根据原则2访问的对象加锁此时 (5,10]
   - 优化1:等值查询(5,10]降级为(5,10)
   - 优化2:此时查询字段为id,不需要回表查询即不会在id=5上加行锁,此时可以更新id=5
   - lock in share mode:只会锁覆盖索引,不会锁主键;当for update时,innodb认为你查询后会根据id更新此时会获取id=5的行锁

3. 主键索引范围锁

   ```sql
   select * from t where id = 10  for update;
   select * from t where id >= 10 and id < 11 for update;
   ```

   - 两者查询结果相同加锁不同,方式1:10在 (5,10]区间,满足优化1:等值,唯一索引 降级为行锁 id=5
   - 找到第一行id=10的,即(5,10] 满足优化1:退化为行锁 id=10
   - 向右遍历找到第一个不满足条件数15,此时原则2访问数据(10,15] 此时id=15是范围查找到的不能通过等值来降级

4. 非唯一索引范围锁

   ```sql
   select * from t where c>=10 and c<10 for update;
   ```

   - 通过c=10去查找,区间:(5,10]
   - 由于是普通索引需要向右遍历找到第一个不相等值,15 即(10,15],向右遍历过程是范围查询无法优化
   - c next-key lock:(5,15]  id:10 record-lock

5. 唯一索引范围锁bug

   ```sql
   begin;
   select * from t where id > 10 and id <= 15 for update;
   ```

   - 根据原则1:通过id=15去主键索引查询,区间 (10,15] next-key
   - 本质上根据主键查询到id=15后不会像右继续查找,存在bug 如果主键索引上范围查询,会找到下一个不满足条件的索引,即id=20  (15,20] next-key
   - (10,20] next-key

6. 非唯一索引上存在的等值

   ```sql
   insert into t values(30,10,30);
   此时普通索引:10  对应两条数据 id:10  id:30
   
   begin;
   delete from t where c=10
   ```

   - 根据c=10条件查询c索引 c=10  此时区间 (5,10]    对应的(c,id)是(5,5)和(10,10) next-key lock
   - 普通索引向右遍历,原则2:访问到的元素,区间(10,15]  对应的(c,id)是 (10,30)和(15,15) next-key lock
   - 根据优化2:等值查询,15条件不满足退化为gap-lock
   - 此时加锁区间为(c,id)   (5,5)-(10,10)-(10,30)-(15,15)     c:(5,15)   id:行锁 10,30

7. limit语句加锁

   ```sql
   delete from t where c=10 limit 2;
   ```

   - 通过c=10从普通索引上查找,区间(5,10]
   - 开始向右遍历找到满足条件元素 (c,id)   (10,10)  (10,30)  由于找到两条数据从c索引上的查找满足limit 2结束,此时不需要继续向右找到c=15的元素
   - 此时区间为(c,id)   (5,5)-(10,10)-(10,30)  普通索引c:(5,10] id: 10和30 record lock

8. 死锁的案例

   ```sql
   session A:
   select * from t where c=10 lock in share mode;
   session B:
   update t set d=d+1 where c=10
   session A:
   insert into t values(8,8,8);
   session B:
   dead lock
   ```

   - session A 第一步:获取到 (5,10] next-key  (10,15) gap
   - session B 第一步获取到:(5,10) (10,15) gap  获取 10:record lock 阻塞,因为session A获取了行锁,间隙锁和间隙锁之间不阻塞
   - session A 第二步:插入(8,8,8)被间隙锁区间(5,10)锁住,此时session A等待session b释放间隙锁(5,10),session B等待session A释放行锁,出现死锁