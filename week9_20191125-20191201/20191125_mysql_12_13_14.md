## mysql 抖动分析

1. 脏页
   最新数据在内存中存在,磁盘上不存在,这一部分数据称为脏页
2. 干净页
   内存和磁盘中都存在,这一部分数据称为干净页
3. 脏页flush情况
   - redo log写满,需要移动checkpoint点,将checkpoint移动新老位置的数据取出,判断这部分数据是否是脏页,将这部分脏页数据刷新到磁盘后移动checkpoint点;(redo log刷新时,对外不提供服务 redo log无法写入)
   - 内存不足,需要将内存中脏页数据刷新到磁盘
   - 空闲时间,空闲时间刷新脏页数据
   - mysql stop,脏页刷新磁盘
4. redo log和内存刷新参数设置为多少合适
   - 当查询过程需要淘汰大量的脏页的数据时,请求的响应时间变长
   - redo log写满了,所有的更新请求阻塞写性能0
   - 当脏页刷新还没写入快的时候容易出现频繁的刷新脏页数据导致写性能为0
   - 确定性能:脏页比例+redo log写盘速度

## 表数据删除

1. 数据空间复用:比如当前页中存在数据 100 200 300,如果删除该页200的数据,200的位置标记位可复用之后插入100到300之间的数据可以复用当前位置
2. 页复用:当该页上的所有数据都可以被复用的时候,当前页被标记位可复用;当新插入的数据需要新的页时可以复用该页
3. 数据存储格式:页(地址值)  页上数据(数组顺序存储)  父节点页(地址值) 父节点数据(left + right + 数组下标)
4. 空间复用只是标记了可复用,但磁盘的文件大小是没变的,会生成很多的位置空洞情况
5. alter table engine = Innodb 来清除;原理在Innodb存储引擎中生成一份临时文件,数据从当前页拷贝;在整理临时文件将页数据重新紧凑排版;如果这个过程中新的数据插入则保存到row log中,之后再恢复到拷贝的新文件中
   对server层来说是原地拷贝(inplace);Innodb即online(1.MDL写锁 MDL读锁 DDL MDL写锁 MDL读锁)

## count()

1. count(*):遍历所有数据,不返回行数据,执行器+1
2. count(1):遍历所有数据,返回行数据+1(不判断为空)
3. count(id):走最小索引树,如果没有则走id,返回给执行器id,执行器判断是否为空 不为空则+1
4. count(字段):判断改字段是否是索引,是则走当前字段的索引树,不是则走id
5. 效率: count(*)=count(1) > count(id) > count(字段)