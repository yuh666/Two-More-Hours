## 全字段排序

1. 比如数据库有id,name,age....等字段,id:主键索引 name:普通索引

   ```sql
   select name,age from user where name = "王五" order by age limit 10
   ```

2. 当查询字段较少的时候,首先innodb根据普通索引等值查询王五,直接第一个不满足等于条件或者查询到10条数据为止,执行过程

   - 初始化sort buffer,存放name,age两个字段
   - 根据name="王五"查询普通索引找到第一个满足条件的id
   - 根据id到主键索引查找行记录,取出name,age两个字段,存入到sort buffer中
   - 继续取下一个满足条件的元素,执行第二步和第三步;直到不相等
   - 对sort buffer进行根据age排序,筛选出10条数据,返回结果
   - 注意事项:当sort buffer空间不够时,会使用临时文件来赋值排序,临时文件外部排序即多个文件归并排序

## rowid排序

1. 当数据库有id,name,age,city...等30个字段时 id:主键 name:普通索引

   ```sql
   select * from user where name = "小三" order by age limit 1000
   ```

2. 当查询字段较多时,innodb比较后发现sort buffer放不下,一次读取的行有限此时可能采用rowId排序,执行过程

   - 存储话sort buffer,存放id,age两个字段
   - 根据name="王五"查询普通索引,找到第一个满足条件的id
   - 根据id回表查询,取出行记录中的age,放入到sort buffer中
   - 继续去下一个满足条件元素,重复执行第二步和第三步
   - 对sort buffer中age排序,筛选1000条记录,获取id
   - 根据id回表查询需要查询的所有字段,在返回给客户端
   - 注意事项:两次回表查询操作,sort buffer中存储id和排序字段节约空间,但是磁盘要读取两次

### 联合索引排序

1. 假设建立联合索引(name,age),在使用过程中根据name筛选时age已经排好序,无需filtersort此时可以在extra中看到无filter sort;最好还可以覆盖索引查询即只查询name和age字段,或者不能避免则回表查询

## 临时表

1. 比如随机筛选表中三个单词,words表中有 word字段,比如10000行数据
   

   ```sql
   select word from words order by rand() limit 3
   ```

- 构建临时表字段W和R
- 全表扫描根据主键筛选出表words中的word字段,同时调用随机函数rand()生成R,将数据放入到临时表中,此时无序存储;此时扫描10000行
- 构建sort buffer,包括R和POS(rowid:主键索引-->唯一索引非空-->自动分配6字节rowId);扫描临时表将临时表中R和POS架子啊到sort buffer中此时扫描10000行
- sort buffer排序(此处排序不一定是快速排序,因为只需要3条数据),排序完筛选前三条数据
- 根据前三条数据的POS到临时表中找到对应的W字段即word返回结果,此处需要根据pos到临时表扫描3行
- 排序:此处使用堆排序构建大顶堆(优先队列排序算法,未使用临时文件进行归并排序)

## 随机取值优化

1. 随1取值

   ```sql
   select max(id) from words
   select min(id) from words
   long randomId = (max(id)-min(id))*random()+min(id):生成随机id
   select id from words where id >= randomId limit 1
   此时:扫描3行数据,max,min,limit 1 存在问题:概率不等,如果要概念相等则先count后在limit这样扫描行数会增多,不适合场景
   ```

   