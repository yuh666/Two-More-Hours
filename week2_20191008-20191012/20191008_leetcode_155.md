    public class Question155 {

    /**
     * 思路:定义两个栈,数据栈和辅助栈  数据栈:存储元素 辅助栈:用来存储栈中最小元素
     */
    class MinStack {


        /**
         * 数据栈
         */
        private Stack<Integer> dataStack;

        /**
         * 辅助栈  栈顶存储最小元素,用来记录每次push后当前最小元素; 当删除元素时同理弹栈
         */
        private Stack<Integer> helperMinStack;

        /**
         * 辅助栈  栈顶存储最大元素,用来记录每次push后当前最大元素; 当删除元素时同理弹栈
         */
        private Stack<Integer> helperMaxStack;

        /**
         * initialize your data structure here.
         */
        public MinStack() {
            dataStack = new Stack<>();
            helperMinStack = new Stack<>();
            helperMaxStack = new Stack<>();
        }

        /**
         * 辅助栈和数据栈同时放入元素,数据栈直接放入 辅助栈比较栈顶元素 如果小于则放入,如果大于则放入栈顶元素
         *
         * @param x
         */
        public void push(int x) {
            dataStack.push(x);
            if (!helperMinStack.isEmpty()) {
                // 栈中存储最小
                if (helperMinStack.peek() > x) {
                    // 大于
                    helperMinStack.push(x);
                } else {
                    // 小于
                    helperMinStack.push(helperMinStack.peek());
                }

                // 栈中存储最大
                if (helperMaxStack.peek() > x) {
                    helperMaxStack.push(helperMaxStack.peek());
                } else {
                    helperMaxStack.push(x);
                }
            } else {
                helperMinStack.push(x);
                helperMaxStack.push(x);
            }
        }

        /**
         * 删除栈顶元素 同时删除辅助栈
         */
        public void pop() {
            if (dataStack.isEmpty()) {
                throw new RuntimeException("栈顶无元素不能删除");
            }
            dataStack.pop();
            helperMinStack.pop();
            helperMaxStack.pop();
        }

        /**
         * 获取栈顶元素
         *
         * @return
         */
        public int top() {
            if (dataStack.isEmpty()) {
                throw new RuntimeException("栈顶无元素获取失败");
            }
            return dataStack.peek();
        }

        /**
         * 获取最小元素
         *
         * @return
         */
        public int getMin() {
            if (helperMinStack.isEmpty()) {
                throw new RuntimeException("栈顶无元素获取失败");
            }
            return helperMinStack.peek();
        }

        /**
         * 获取最小元素
         *
         * @return
         */
        public int getMax() {
            if (helperMaxStack.isEmpty()) {
                throw new RuntimeException("栈顶无元素获取失败");
            }
            return helperMaxStack.peek();
        }
    }


    /**
     * 最小栈 同理最大栈,通过辅助栈来记录最大元素
     */
    @Test
    public void test1() {
        MinStack minStack = new MinStack();
        minStack.push(-2);
        minStack.push(0);
        minStack.push(-3);
        System.out.println(minStack.getMin()); // -3
        System.out.println(minStack.getMax()); // 0
        minStack.pop();
        System.out.println(minStack.top()); // 0
        System.out.println(minStack.getMin());  // -2
        System.out.println(minStack.getMax()); // 0

    }
}
