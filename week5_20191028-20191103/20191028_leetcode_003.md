    
# 问题描述:
   - 环形链表: https://leetcode-cn.com/problems/linked-list-cycle-ii
    
# 思路:    
    public class Question142 {

    class ListNode {
        int      val;
        ListNode next;

        ListNode(int x) {
            val = x;
            next = null;
        }
    }

    // 思路
    // 设 头结点->入口节点距离为K 环长度为L 慢节点slow 快节点fast
    // 1.快慢节点指向头节点开始走
    // 2.当slow走到入口节点时走了K 那么fast就走了2k 其中一个K和slow的一样 是头结点到入口 另外一个K就是在环上走的长度 K%L (不管走了几圈)
    // 3.接上一条 两个相同速度的节点 当一个节点走了K时 那么另外一个节点 一定在环上走了K%L（不管走了几圈，走的距离一定是K%L）
    // 4.当slow到达入口节点时 fast距离入口 L-(K%L)
    // 5.fast想要追上slow 因为速度是2倍 所以当slow行进他们之间的这段距离时 就追上了(因为fast走了2倍) 此时fast和slow相遇的位置离入口的距离就是 L - (L-(K%L)) = K % L
    // 第二三条我们证明了 两个相同速度的节点一个走了K 另外一个一定会在环上走 K % L 所以让一个节点从头走 一个接着走 相遇点就是入口
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                break;
            }
        }
        // 此时 slow == fast或者其中一个节点走完
        if (fast == null || fast.next == null) {
            return null;
        }

        // slow == fast
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }


    @Test
    public void test1() {
        ListNode l1 = new ListNode(3);
        ListNode l2 = new ListNode(2);
        ListNode l3 = new ListNode(0);
        ListNode l4 = new ListNode(-4);
        l1.next = l2;
        l2.next = l3;
        System.out.println(detectCycle(l1));
    }

}
