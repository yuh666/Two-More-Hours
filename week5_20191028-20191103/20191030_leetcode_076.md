    
# 问题描述:
   - 最长子串: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
    
# 思路:    
    public class Question003 {

    /**
     * flag和i两个标记:i为当前遍历元素下标 flag记录与i重复的字符位置
     * 比如 abcabcbb flag=0,i=0 遍历 i=3时 flag,i都为a 此时i=flag即最大子串长度,flag+1然后继续遍历i,下次重复时候判断长度是否大于上一次长度
     *
     * @param s
     * @return
     */
    public int lengthOfLongestSubstring(String s) {
        int i = 0, flag = 0;
        int length = 0;
        int result = 0;
        while (i < s.length()) {
            // 找i从flag开始出现相同数的位置
            int pos = s.indexOf(s.charAt(i), flag);
            if (pos < i) {
                // 当pos 小于i的时候代表 i与flag位置重复
                // 判断当前length是否大于result
                if (length > result) {
                    // 该子串比前面的大
                    result = length;
                }

                // 优化点 该子串的长度已经大于了剩余所有字符的长度
                if (result >= s.length() - pos - 1) {
                    return result;
                }
                length = i - pos - 1;
                flag = pos + 1;

            }
            length++;
            i++;
        }
        return length;
    }

    /**
     * 滑动窗口
     * 假设 [i,j) 之前不存在重复的元素,此时只需要判断j是否在 [i,j)的字符中,i到j的元素可以通过hashSet来存储 这样不需要遍历整个i,j的范围 o(1)判断
     * 如果当j在[i,j)中存在的时候,则i+1 重新的去滑动
     * 缺点:在滑动的过程中[i+1,j)移动的过程中存在[i,j)重复的判断
     *
     * @param s
     * @return
     */
    public int lengthOfLongestSubstring2(String s) {
        int result = 0;
        int length = s.length();
        Set<Character> set = new HashSet<>();
        int i = 0, j = 0;
        while (i < length && j < length) {
            if (!set.contains(s.charAt(j))) {
                // [i,j)中不包含j 1.添加到set 2.计算长度 3.放入到result中
                set.add(s.charAt(j++));
                result = Math.max(result, j - i);
            } else {
                // 存在 j即删除i 同时i++ 即向右滑动
                set.remove(s.charAt(i++));
            }
        }
        return result;
    }

    /**
     * 滑动窗口
     * 假设 [i,j) 之前不存在重复的元素,此时只需要判断j是否在 [i,j)的字符中,i到j的元素可以通过hashSet来存储 这样不需要遍历整个i,j的范围 o(1)判断
     * 如果当j在[i,j)中存在的时候,则i+1 重新的去滑动
     * 缺点:在滑动的过程中[i+1,j)移动的过程中存在[i,j)重复的判断
     * <p>
     * 优化方式:当[i,j)中存在k与j重复的时候,我们将i直接跳到k的位置在滑动 因为[i,j)中最大不重复已求出
     *
     * @param s
     * @return
     */
    public int lengthOfLongestSubstring3(String s) {
        int result = 0;
        int length = s.length();
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0, j = 0; j < length; j++) {
            if (map.containsKey(s.charAt(j))) {
                // 包含重置i
                i = Math.max(map.get(s.charAt(j)), i);
            }
            // 将当前元素放入到map中
            result = Math.max(result, j - i + 1);
            map.put(s.charAt(j), j + 1);
        }
        return result;
    }

    @Test
    public void test1() {
        System.out.println(lengthOfLongestSubstring3("abcabcdbb"));
        System.out.println(lengthOfLongestSubstring2("bbbbb"));
        System.out.println(lengthOfLongestSubstring("bbbbb"));
        System.out.println(lengthOfLongestSubstring("pwwkew"));
        System.out.println(lengthOfLongestSubstring(" "));
        System.out.println(lengthOfLongestSubstring("pmukfzdskwdyne"));
    }
}
