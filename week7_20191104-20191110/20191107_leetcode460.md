```java
class LFUCache {

    private Node[] container;

    private int containerSize;

    private Map<Integer, Integer> containerIndexMap;

    private int[] minHeap;

    private int minHeapSize;

    private int capacity;

    private int timestamp = 0;

    public LFUCache(int capacity) {
        this.container = new Node[capacity];
        this.containerSize = 0;
        this.containerIndexMap = new HashMap<>(capacity * 2);
        this.minHeap = new int[capacity + 1];
        this.minHeapSize = 1;
        this.capacity = capacity;
    }

    public int get(int key) {
        Integer containerIndex = containerIndexMap.get(key);
        if (containerIndex == null) {
            return -1;
        }
        int val = container[containerIndex].value;
        container[containerIndex].useCount++;
        container[containerIndex].timestamp = timestamp++;
        heapify();

        return val;
    }

    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        Integer containerIndex = containerIndexMap.get(key);

        if (containerIndex != null) {
            container[containerIndex].value = value;
            container[containerIndex].useCount++;
            container[containerIndex].timestamp = timestamp++;
            heapify();
            return;
        }

        // 当需要提出元素时，记录要剔除元素的下标
        int preRemoveElementIndex = -1;
        if (containerSize >= capacity) {
            preRemoveElementIndex = containerIndexMap.remove(container[minHeap[1]].key);
            minHeap[1] = minHeap[--minHeapSize];
            shiftDown(1);
        }

        int newElementIndex = preRemoveElementIndex;
        if (newElementIndex == -1) {
            newElementIndex = containerSize++;
        }

        container[newElementIndex] = new Node(key, value, 0, timestamp++);
        containerIndexMap.put(key, newElementIndex);
        minHeap[minHeapSize++] = newElementIndex;
        shiftUp(minHeapSize - 1);
    }

    /**
     * @param me shiftUp之前的位置
     * @return shiftUp之后的位置
     */
    private int shiftUp(int me) {
        while (me > 1 && me < minHeapSize) {
            int parent = minHeap[me / 2];
            if ((container[parent].useCount < container[minHeap[me]].useCount) ||
                    (container[parent].useCount == container[minHeap[me]].useCount && container[parent].timestamp < container[minHeap[me]].timestamp)) {
                break;
            }
            int parentIndex = me / 2;
            change(parentIndex, me);
            me = parentIndex;
        }
        return me;
    }

    /**
     * @param me shiftDown之前的位置
     * @return shiftDown之后的位置
     */
    private void shiftDown(int me) {
        while (me <= (minHeapSize - 1) / 2) {
            int son = minUseCountIndex(me * 2, me * 2 + 1);

            if ((container[minHeap[son]].useCount > container[minHeap[me]].useCount) ||
                    (container[minHeap[son]].useCount == container[minHeap[me]].useCount && container[minHeap[son]].timestamp > container[minHeap[me]].timestamp)) {
                break;
            }

            change(son, me);
            me = son;
        }
    }

    private int minUseCountIndex(int aIndex, int bIndex) {
        if (aIndex < minHeapSize && bIndex < minHeapSize) {
            int aNode = minHeap[aIndex];
            int bNode = minHeap[bIndex];
            if (container[aNode].useCount == container[bNode].useCount) {
                return container[aNode].timestamp < container[bNode].timestamp ? aIndex : bIndex;
            }
            return container[aNode].useCount < container[bNode].useCount ? aIndex : bIndex;
        }
        return aIndex < minHeapSize ? aIndex : bIndex;
    }

    private void change(int aIndex, int bIndex) {
        int temp = minHeap[aIndex];
        minHeap[aIndex] = minHeap[bIndex];
        minHeap[bIndex] = temp;
    }

    private class Node {
        int key;
        int value;
        int useCount;
        long timestamp;

        private Node(int key, int value, int useCount, long timestamp) {
            this.key = key;
            this.value = value;
            this.useCount = useCount;
            this.timestamp = timestamp;
        }
    }

    private void heapify() {
        for (int i = (minHeapSize - 1) / 2; i > 0; i--) {
            shiftDown(i);
        }
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```