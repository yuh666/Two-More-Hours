    
# 问题描述:
   - 不同的二叉搜索树 https://leetcode-cn.com/problems/unique-binary-search-trees/submissions/
    
# 思路:    
    public class Question096 {

    class Solution {

        /**
         * 思路:
         * 1.满足二叉搜索树, 当前元素左节点小右节点大
         * 2.假设当前节点n为跟节点,则 G(n) = G(1)+....+G(n)
         * 3.假设当前根节点为i,则小于i的左节点的个数为i-1个,右节点的个数为n-i个 左为(1,i-1) 右为(i,n) G(i)=G(i-1)*G(n-i)
         * 则 G(n)=G(0)(n) + G(1)(n-1) + ...+G(n-1)(0)
         * @param n
         * @return
         */
        public int numTrees(int n) {
            int[] numTrees = new int[n + 1];
            numTrees[0] = 1;

            // i即当前节点个数,j即遍历到的当前根节点
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    numTrees[i] += numTrees[j - 1] * numTrees[i - j];
                }
            }
            return numTrees[n];
        }
    }

    @Test
    public void test1() {
        Solution solution = new Solution();
        System.out.println(solution.numTrees(3));
    }
}
