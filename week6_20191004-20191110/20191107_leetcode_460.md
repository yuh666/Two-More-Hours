    
# 问题描述:
   - LRU缓存 https://leetcode-cn.com/problems/lfu-cache
    
# 思路:    
    public class Question460 {

    /**
     * 节点信息
     */
    class Node {
        public Integer key;
        public Integer value;
        public Integer times;
        public Node    pre;
        public Node    next;

        public Node(Integer key, Integer value, Integer times) {
            this.key = key;
            this.value = value;
            this.times = times;
        }
    }

    /**
     * 桶信息
     */
    class BucketNode {
        /**
         * 桶中头节点
         */
        public Node head;

        /**
         * 尾节点
         */
        public Node tail;

        /**
         * 桶与桶之前的前驱节点
         */
        public BucketNode pre;

        /**
         * 桶与桶之前的后继节点
         */
        public BucketNode next;

        public BucketNode(Node node) {
            this.head = node;
            this.tail = node;
        }

        /**
         * 添加节点到当前桶下双向链表头部节点
         */
        public void addToHead(Node node) {
            node.next = head;
            node.pre = null;
            head.pre = node;
            head = node;
        }

        /**
         * 删除指定节点
         * 1.当前只有一个节点
         * 2.当前节点为头节点
         * 3.当前节点为尾节点
         * 4.当前节点为普通节点
         *
         * @param node
         */
        public void deleteNode(Node node) {
            if (head == tail) {
                head = null;
                tail = null;
                return;
            }
            if (head == node) {
                head = node.next;
                head.pre = null;
            } else if (tail == node) {
                tail = node.pre;
                tail.next = null;
            } else {
                node.pre.next = node.next;
                node.next.pre = node.pre;
            }
        }

        /**
         * 判断当前桶是否为空
         *
         * @return
         */
        public boolean isEmpty() {
            return head == null;
        }
    }

    /**
     * 思路:lfu缓存:含义是使用频率越少的淘汰,比较使用数据的次数 次数最少的淘汰,次数相同的淘汰最先入队列的元素
     * <p>
     * 因为每个操作是O(1)
     * <p>
     * 相同次数的节点在同一个桶中,桶和桶之间通过双向链表来关联 使用最少次数的桶在双向链表头节点
     * 每个桶中的元素即访问频率相同的节点,桶中元素双向链表 新加入的节点在桶的head 即将被淘汰的节点在tail
     * <p>
     * 将往桶中添加元素时,即头部添加
     * 桶中删除某个节点时,判断当前节点的位置 head tail 其他位置
     */
    class LFUCache {

        /**
         * 记录key和节点信息
         */
        private HashMap<Integer, Node> records;

        /**
         * 记录当前节点所在桶信息
         */
        private HashMap<Node, BucketNode> bucketRecords;

        /**
         * 桶之间双向链表的头节点,访问次数最少的桶
         */
        private BucketNode headBucket;

        private Integer capacity;

        private Integer size;

        public LFUCache(int capacity) {
            this.capacity = capacity;
            this.size = 0;
            records = new HashMap<>();
            bucketRecords = new HashMap<>();
            headBucket = null;
        }

        /**
         * 获取元素
         * 1.判断当前key是否存在 不存在返回-1,存在:根据key获取当前节点信息,根据节点信息获取桶信息,将节点元素移动到下一个桶
         * (此时需要判断当前桶+1次数的桶是否存在,存在添加到head,不存在创建一个桶)
         *
         * @param key
         * @return
         */
        public int get(int key) {
            if (!records.containsKey(key)) {
                return -1;
            }
            Node node = records.get(key);
            node.times++;
            BucketNode bucketNode = bucketRecords.get(node);
            move(node, bucketNode);
            return node.value;
        }

        /**
         * 移动指定桶中的节点
         * 1.删除指定桶中的指定节点
         * 2.插入节点到新的桶中
         *      1.判断当前桶的下一个桶是否为空
         *          1.为空:创建新桶,新桶为当前桶的后继节点
         *              1.判断当前桶是否为空
         *                  为空:判断是否是头号桶
         *                      是:新桶为头号桶
         *                      不是:删除当前桶 即新桶变成当前桶的位置
         *          2.不为空:获取下一个桶
         *              1.判断下一个桶的次数是否跟新桶次数相等
         *                  1.相等
         *                      1.添加到下一个桶的头部,同时修改当前节点的桶位置信息
         *                  2.不相等
         *                      1.将当前桶插入到当前桶和下一个桶的中间
         *              2.判断当前桶是否为空
         *                  1.为空:判断是否是头号桶
         *                      1.是头号桶:头号桶为新桶位置
         *                      2.不是头号桶:新桶放入当前桶位置
         *
         *                  2.不为空:不处理
         *
         * 1.相等 加入到下一桶节点的头部
         * 2.不相等 创建一个新的桶,插入到当前old桶和old.next的中间,节点属于新桶
         * 2.判断old桶的元素是否为空
         * 1.为空    删除old桶 old.pre指向空 同时为headBucket
         * 2.不为空 无需改变
         *
         * @param node
         * @param oldBucketNode
         */
        private void move(Node node, BucketNode oldBucketNode) {
            // 0.记录当前节点是否是headBucket
            boolean flag = oldBucketNode == headBucket;
            // 1.删除桶中节点
            oldBucketNode.deleteNode(node);
            // 2.插入节点到新的桶
            // 此时需要判断oldBucketNode桶是否有下一个桶
            if (oldBucketNode.next == null) {
                // oldBucketNode 不存在下一个桶,此时重置当前节点,创建新桶
                node.pre = null;
                node.next = null;
                BucketNode newBucketNode = new BucketNode(node);
                // oldBucketNode指向newBucketNode
                oldBucketNode.next = newBucketNode;
                newBucketNode.pre = oldBucketNode;
                // 判断oldBucketNode是否为空
                if (oldBucketNode.isEmpty()) {
                    // 为空 此时需要判断
                    if (flag) {
                        // 当前桶为headBucket
                        newBucketNode.pre = null;
                        headBucket = newBucketNode;
                    } else {
                        // 当前桶不为headBucket
                        oldBucketNode.pre.next = oldBucketNode.next;
                        oldBucketNode.next.pre = oldBucketNode.pre;
                    }
                }
                // 替换当前节点的桶位置
                bucketRecords.put(node, newBucketNode);
            } else {
                // 下一个桶不为空
                // 判断当前节点和下一个桶的次数
                BucketNode nextBucketNode = oldBucketNode.next;
                if (Objects.equals(node.times, nextBucketNode.head.times)) {
                    // 相等 则当前节点加入到下一个桶
                    nextBucketNode.addToHead(node);
                    // 新节点桶变化
                    bucketRecords.put(node, nextBucketNode);
                } else {
                    // 不相等 则创建一个桶
                    BucketNode newBucketNode = new BucketNode(node);
                    // 将新桶插入到oldBucketNode和oldBucketNode之间
                    newBucketNode.next = oldBucketNode.next;
                    newBucketNode.pre = oldBucketNode;
                    oldBucketNode.next.pre = newBucketNode;
                    oldBucketNode.next = newBucketNode;
                    newBucketNode.next.pre = newBucketNode;
                    // 跟换node对应的桶信息
                    bucketRecords.put(node, newBucketNode);
                }
                // 判断oldBucketNode是否为空
                if (oldBucketNode.isEmpty()) {
                    // 为空 此时需要判断是否为headBucket
                    if (flag) {
                        // 当前桶为headBucket
                        oldBucketNode.next.pre = null;
                        headBucket = oldBucketNode.next;
                    } else {
                        // 当前桶不为headBucket
                        oldBucketNode.pre.next = oldBucketNode.next;
                        oldBucketNode.next.pre = oldBucketNode.pre;
                    }
                }
            }
        }

        /**
         * 修改头号桶
         * <p>
         * 1.判断头号桶是否为空
         * 1.头号桶为空
         * 1.改变头号桶
         * 2.头号桶不为空
         * 不做任何改变
         *
         * @param headBucketNode
         * @return
         */
        private void modifyHeadBucket(BucketNode headBucketNode) {
            if (headBucketNode.isEmpty()) {
                // 改变头号桶
                if (headBucketNode.next != null) {
                    BucketNode nextBucketNode = headBucketNode.next;
                    nextBucketNode.pre = null;
                    this.headBucket = nextBucketNode;
                }
            }
        }

        /**
         * 添加元素:
         * 1.判断当前元素是否存在
         * 1.存在
         * 根据key获取当前节点,访问次数+1
         * 根据当前节点获取桶信息
         * 移动当前节点位置(包括当前节点删除桶中指定节点元素,创建或移动当前节点到指定桶)
         * 2.不存在
         * 1.判断当前容量是否满了
         * 满了:删除headBucket中尾节点(此时可能存在当前桶只有一个元素,删除完桶后需要将桶的后继节点作为headBucket)
         * 没满,判断当前headBucket次数是否和新节点次数相同,相同则插入到headBucket头部 不相同则创建一个桶节点插入到头部
         *
         * @param key
         * @param value
         */
        public void put(int key, int value) {
            // 容量为0
            if (capacity == 0) {
                return;
            }
            if (records.containsKey(key)) {
                // 当前节点存在
                Node node = records.get(key);
                node.times++;
                // put元素值可能替换
                node.value = value;
                BucketNode bucketNode = bucketRecords.get(node);
                move(node, bucketNode);
            } else {
                // 不存在
                if (size >= capacity) {
                    // 容量满了
                    Node node = headBucket.tail;
                    headBucket.deleteNode(node);
                    modifyHeadBucket(headBucket);
                    records.remove(node.key);
                    bucketRecords.remove(node);
                    size--;
                }
                // 添加当前节点到指定桶中
                Node node = new Node(key, value, 1);
                if (headBucket == null || headBucket.isEmpty()) {
                    headBucket = new BucketNode(node);
                } else {
                    // 判断当前节点和headBucket的次数
                    if (Objects.equals(headBucket.head.times, node.times)) {
                        // 次数相等 则添加到头部
                        headBucket.addToHead(node);
                    } else {
                        // 不相等 则创建一个桶添加到头部
                        BucketNode bucketNode = new BucketNode(node);
                        // 指定bucketNode的前驱节点和后继节点
                        bucketNode.next = headBucket;
                        bucketNode.pre = null;
                        headBucket.pre = bucketNode;
                        headBucket = bucketNode;
                    }
                }
                size++;
                records.put(key, node);
                bucketRecords.put(node, headBucket);
            }
        }
    }


    @Test
    public void test1() {
        LFUCache lfuCache = new LFUCache(2);
        lfuCache.put(3, 1);
        lfuCache.put(2, 1);
        lfuCache.put(2, 2);
        lfuCache.put(4, 4);
        System.out.println(lfuCache.get(2));
    }
}
