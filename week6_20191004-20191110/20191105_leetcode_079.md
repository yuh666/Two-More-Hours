    
# 问题描述:
   - 单词搜索 https://leetcode-cn.com/problems/word-search
    
# 思路:    
    public class Question079 {

    /**
     * 思路:回溯算法
     * 每次选择一个元素作为开始元素,然后以当前元素去回溯来判断后续结果
     */
    class Solution {
        public boolean exist(char[][] board, String word) {
            // 遍历行和列 选择开始元素
            char[] wordArray = word.toCharArray();
            for (int row = 0; row < board.length; row++) {
                for (int column = 0; column < board[0].length; column++) {
                    if (search(board, wordArray, 0, row, column)) {
                        // 满足条件返回true
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * 找对应的字符是否存在
         * 1.当前字符 row和column未超过指定区间限制,并且 board[row][column]=
         * 2.当 pos+1=word.length时 返回true即搜索到该词
         * 3.当前元素满足,对应的pos+1元素 在其当前元素的 左(row,column-1),右(row,column+1)
         * 上(row-1,column),下(row+1,column) 只要有一个满足即pos+1满足
         *
         * @param board
         * @param wordArray
         * @param pos       当前查询元素的下标 比如 word=ABCCED  pos从0开始 当pos=5 满足时此时匹配到了整个字符串
         * @param row
         * @param column
         * @return
         */
        private boolean search(char[][] board, char[] wordArray, int pos, int row, int column) {
            // 满足区间和元素相等
            if (row < 0 || row > board.length - 1 || column < 0 || column > board[0].length - 1
                    || board[row][column] != wordArray[pos]) {
                return false;
            }

            // 是否满足 pos+1=wordArray.length
            if (pos + 1 == wordArray.length) {
                return true;
            }

            // 将当前元素用*代替防止下一元素回溯的时候次元素第二次被利用
            char temp = board[row][column];
            board[row][column] = '*';
            // 左 右 上 下
            boolean flag = search(board, wordArray, pos + 1, row, column - 1) || search(board, wordArray, pos + 1, row, column + 1)
                    || search(board, wordArray, pos + 1, row - 1, column) || search(board, wordArray, pos + 1, row + 1, column);
            board[row][column] = temp;
            return flag;
        }
    }

    @Test
    public void test1() {
        Solution solution = new Solution();
        char[][] board = new char[3][4];
        board[0] = new char[]{'A', 'B', 'C', 'E'};
        board[1] = new char[]{'S', 'F', 'C', 'S'};
        board[2] = new char[]{'A', 'D', 'E', 'E'};
        System.out.println(solution.exist(board, "ABCCED"));
        System.out.println(solution.exist(board, "SEE"));
        System.out.println(solution.exist(board, "ABCB"));
    }
}
