    
# 问题描述:
   - LRU缓存机制 https://leetcode-cn.com/problems/lru-cache
    
# 思路:    
    public class Question146 {

    /**
     * map+双向链表
     * 思路: map<key,Node> key:代表当前put元素key值 Node包含: key value pre next
     * <p>
     * put操作:
     * 1.判断map中key是否存在
     * 1.1 存在
     * 取到当前元素的node节点
     * 设置node节点的值为新值
     * 将该节点移动到头部
     * <p>
     * 1.2 不存在
     * 判断当前元素是否满了
     * 1.满了
     * 1.淘汰末尾元素 容量-1
     * 2.执行未满的操作(同步骤2)
     * <p>
     * 2.没满
     * 1.创建该节点
     * 2.将该节点移动到头部
     * 3.将该节点放入map中
     * 4.容量+1
     */
    class LRUCache {

        /**
         * 头节点
         */
        private Node head;

        /**
         * 未节点
         */
        private Node tail;

        /**
         * 最大容量
         */
        private Integer capacity;

        /**
         * 当前存储数据个数
         */
        private Integer size;

        private Map<Integer, Node> map;

        public LRUCache(int capacity) {
            this.capacity = capacity;
            this.size = 0;
            this.map = new HashMap<>();
        }

        /**
         * get操作:
         * 1.判断当前元素是否存在
         * 1.1 存在
         * 获取当前节点,将当前节点移动到head,返回节点数据
         * 1.2 不存在返回false
         *
         * @param key
         * @return
         */
        public int get(int key) {
            if (map.containsKey(key)) {
                Node node = map.get(key);
                moveToHead(node);
                return node.value;
            }
            return -1;
        }

        /* put操作:
         *  1.判断map中key是否存在
         *      1.1 存在
         *              取到当前元素的node节点
         *              设置node节点的值为新值
         *              将该节点移动到头部
         *
         *      1.2 不存在
         *         判断当前元素是否满了
         *         1.满了
         *          1.淘汰末尾元素 容量-1
         *          2.执行未满的操作(同步骤2)
         *
         *         2.没满
         *          1.创建该节点
         *          2.将该节点移动到头部
         *          3.将该节点放入map中
         *          4.容量+1
         */

        /**
         * 添加元素
         *
         * @param key
         * @param value
         */
        public void put(int key, int value) {
            // 1.判断map中元素是否存在
            if (map.containsKey(key)) {
                // 存在
                // 1.获取当前节点
                Node node = map.get(key);
                // 2.修改当前节点的value值
                node.value = value;
                // 3.移动当前节点到头部
                moveToHead(node);
            } else {
                // 不存在
                // 1.判断容量是否满了
                if (size >= capacity) {
                    // 满了
                    // 1.淘汰末尾节点
                    outTailNode();
                    // 执行未满操作 此时提取公共部分
                }

                // 未满
                // 1.创建当前节点
                Node node = new Node(key, value);
                // 判断当前是否为空,head和tail未初始化
                if (size == 0) {
                    head = node;
                    tail = node;
                } else {
                    // 2.移动当前节点到头节点
                    moveToHead(node);
                }
                // 3.容量+1
                size++;
                // 4.put当前节点到map中
                map.put(key, node);
            }
        }

        /**
         * 淘汰末尾节点
         */
        private void outTailNode() {
            if (tail != null) {
                map.remove(tail.key);
                // 重置tail节点
                tail = tail.pre;
                if (tail == null) {
                    // 当未节点前驱节点为空时 即当前节点也是head节点
                    head = null;
                } else {
                    // 当未节点空时,未节点对应的next节点重置为空
                    tail.next = null;
                }
                size--;
            }
        }

        /**
         * 移动当前节点到头节点
         *
         * @param node
         */
        private void moveToHead(Node node) {
            // 1.判断当前节点是否是头节点
            if (node == head) {
                // 是头结点不需要移动
                return;
            }
            // 2.当前节点不是头节点
            // 3.将当前节点的前驱节点的next执行当前节点next
            if (node.pre != null) {
                node.pre.next = node.next;
            }
            // 4.将当前节点的后继节点的前驱节点指定当前节点的pre
            if (node.next != null) {
                node.next.pre = node.pre;
            }
            // 5.当前节点是未节点
            if (node == tail) {
                tail = tail.pre;
            }
            // 5.当node节点移动到头节点
            node.pre = null;
            node.next = head;
            head.pre = node;
            head = node;
        }

        /**
         * 双向链表
         */
        class Node {
            private Integer key;

            private Integer value;

            private Node pre;

            private Node next;

            public Node(Integer key, Integer value) {
                this.key = key;
                this.value = value;
            }
        }
    }

    @Test
    public void test1() {
        LRUCache cache = new LRUCache(2);
        cache.put(1, 1);
        cache.put(2, 2);
        cache.get(1);       // 返回  1
        cache.put(3, 3);    // 该操作会使得密钥 2 作废
        cache.get(2);       // 返回 -1 (未找到)
        cache.put(4, 4);    // 该操作会使得密钥 1 作废
        cache.get(1);       // 返回 -1 (未找到)
        cache.get(3);       // 返回  3
        cache.get(4);       // 返回  4
    }
}
