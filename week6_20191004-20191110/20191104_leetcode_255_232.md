    
# 问题描述:
   - 用队列实现栈 https://leetcode-cn.com/problems/implement-stack-using-queues
   - 用栈实现队列 https://leetcode-cn.com/problems/implement-queue-using-stacks
    
# 思路:    
    public class Question225 {

    /**
     * 通过队列来实现栈  队列先进先出,栈先进后出
     * 0.创建两个队列   输入队列input和输出队列output
     * 比如  1,2,3,4
     * 栈中添加一个元素:
     * 1.添加到输入队列 input:1
     * 2.判断输出队列是否为空,不为空则将output中元素出队列添加到input队列
     * 3.input和output交换,保证input队列永远为空
     * <p>
     * push:1   input:1 output:null  交换input和output  此时 input:null output:1
     * push:2   input:2 output:1  output出队列给input input:1,2  交换: input:null output:1,2
     * push:3  同理 ... input:null output:1,2,3
     * <p>
     * 栈的操作即output队列的操作
     */
    class MyStack {

        /**
         * 入队队列
         */
        private Queue<Integer> input;

        /**
         * 出队队列
         */
        private Queue<Integer> output;

        /**
         * Initialize your data structure here.
         */
        public MyStack() {
            input = new LinkedList<>();
            output = new LinkedList<>();
        }

        /**
         * Push element x onto stack.
         */
        public void push(int x) {
            // 1.添加到入队队列
            input.offer(x);
            // 2.将出队队列添加到入队队列
            while (!output.isEmpty()) {
                input.offer(output.poll());
            }
            // 3.交换入队和出队队列
            Queue temp = output;
            output = input;
            input = temp;
        }

        /**
         * Removes the element on top of the stack and returns that element.
         */
        public int pop() {
            return output.poll();
        }

        /**
         * Get the top element.
         */
        public int top() {
            return output.peek();
        }

        /**
         * Returns whether the stack is empty.
         */
        public boolean empty() {
            return output.isEmpty();
        }
    }

    @Test
    public void test1() {

        MyStack obj = new MyStack();
        obj.push(22);
        obj.push(33);
        int param_2 = obj.pop();
        System.out.println(param_2); // 33
        int param_3 = obj.top();
        System.out.println(param_3); // 22
        boolean param_4 = obj.empty();
        System.out.println(param_4); // false
    }
    }
    
    public class Question232 {
    /**
     * 队列先进先出,栈先进后出
     * <p>
     * 思路:
     * 0.创建两个栈  一个输入栈input 输出栈output
     * 比如: 1,2,3,4
     * 1.将output中元素弹栈添加到input中
     * 2.添加元素到input
     * 3.交换input output元素 input:null output:元素
     * <p>
     */
    class MyQueue {

        /**
         * 输入
         */
        private Stack<Integer> input;

        /**
         * 输出
         */
        private Stack<Integer> output;

        /**
         * Initialize your data structure here.
         */
        public MyQueue() {
            input = new Stack();
            output = new Stack();
        }

        /**
         * Push element x to the back of queue.
         */
        public void push(int x) {
            // 1.将output中元素弹栈到input中
            while (!output.isEmpty()) {
                input.push(output.pop());
            }
            input.push(x);
            while (!input.isEmpty()) {
                output.push(input.pop());
            }
        }

        /**
         * Removes the element from in front of queue and returns that element.
         */
        public int pop() {
            return output.pop();
        }

        /**
         * Get the front element.
         */
        public int peek() {
            return output.peek();
        }

        /**
         * Returns whether the queue is empty.
         */
        public boolean empty() {
            return output.isEmpty();
        }
    }

    @Test
    public void test1() {
        MyQueue queue = new MyQueue();

        queue.push(1);
        queue.push(2);
        System.out.println(queue.peek()); // 返回 1
        System.out.println(queue.pop());  // 返回 1
        queue.empty(); // 返回 false
    }
}
