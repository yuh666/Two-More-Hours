### 一条SQL更新语句是如何执行的?

- [x] redo日志介绍?
  innodb存储引擎支持事物独有,用来当mysql宕机的时候数据 不丢失,可以通过redo日志来crash-safe能力

- [x] 为啥有redo日志和binlog日志?
  之前mysql默认的存储引擎为MyISAM,不支持事物和mvcc多版本控制;集成innodb作为mysql的默认存储引擎的时候引入了redo日志,redo日志记录已提交事物的数据,防止mysql宕机导致数据丢失,存储在innodb存储引擎中;binlog日志是所有存储引擎共享的存储在server端

- [x] redo日志和binlog日志的不同?

  1.相同 redo日志和binlog日志都是二进制的方式存储
  2.不同点:

  1. 存储位置:redo存储在innodb存储引擎中,binlog日志存储在server端
  2. redo是物理日志,记录的是在某个数据页修改了什么内容;binlog是逻辑日志,记录的执行执行语句.
     binlog:通过 show variables like "%binlog_format"查看格式:
     row:存储的是每一行前后的数据  优点:不会出现通过binlog replication时版本不一致出现sql不支持问题 缺点:存储数据空间增大
     statement:存储的执行的sql语句,存储时需要记录事物id,对replication同步时如果mysql版本不一致会到时数据同步失败
     mixed:row+statement
  3. redo日志是循环写,redo日志中未同步到磁盘的数据是write pos到checkpoint中的数据;binlog是追加写
     
     

- [x] redo日志和binlog日志写入的流程?
  比如 执行update mytest set age =age+1 where id = 1

  1. 执行器调用innodb存储引擎,首先查询sql在缓存中是否存在,存在则直接返回结果,不存在则查询磁盘中的页数据
  2. 存储引擎将数据返回age给server端执行器.执行器将age+1后调用存储引擎的函数,将数据更新到内存中,同时写入innodb存储引擎的redo日志中,此时redo日志处于prepare commit状态.存储引擎告诉执行器事物随时可以提交
  3. 执行器生成该操作的binlog日志,写入到磁盘中.
  4. 执行器调用引擎提交事物的接口,引擎将redo日志改为commit状态
     
     

- [x] 分析事物两阶段提交的好出?
  假设1:当redo日志prepare commit失败时,此时直接失败  master和slave数据保持一致

  假设2:写入redo日志成功,写入binlog日志失败	此时master和slave保持一致,binlog日志写入失败后redo日志回滚
  假设3:写入redo成功,binlog成功,commit失败  此时master和slave短暂不一致,master重启的时候由于redo和binlog中都存在会强行将redo中日志改为commit
  假设4:如果不俩阶段提交
  比如先写redo在写binlog,redo成功此时mysql age:2  binlog失败:age:1因为没有最新的逻辑日志  此时如果数据恢复那么最后恢复数据即age:1

  比如先写binlog在写redo:此时binlog写入成功,age:2  redo写入失败:数据库中age:1   此时数据恢复是:age:2 导致和真实结果不一致
  
  

- [x] binlog备份,是一天一次还是一周一次备份?
  一周一次:假设每周周一备份数据,当周一还未备份本周数据时宕机.此时周日宕机需要拿上周的全备+周一到周日某个时间点的全部binlog日志
  一天一次:假设今天23点宕机,此时需要当天之前的全备+今天23的binlog
  对比后:整个时间相比一天一次吊打一周一次
  数据可靠性:一天只用保证一天的binlog日志完整,一周需要前一周binlog日志和本周的所有

 

  