    
# 问题描述:
   - 二叉搜索树中的搜索 https://leetcode-cn.com/problems/search-in-a-binary-search-tree
   - 交替打印FooBar https://leetcode-cn.com/problems/print-foobar-alternately
    
# 思路:    
    public class Question700 {

    /**
     * 节点信息
     */
    public class TreeNode {
        int      val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    class Solution {

        /**
         * 思路:在二叉树中找到节点信息,返回节点信息
         *
         * @param root
         * @param val
         * @return
         */
        public TreeNode searchBST(TreeNode root, int val) {
            if (root == null) {
                return null;
            }

            if (root.val == val) {
                return root;
            }
            if (root.val > val) {
                // 则在左子数
                root = root.left;
            } else {
                // 右子数
                root = root.right;
            }
            return searchBST(root, val);
        }
    }

    @Test
    public void test1() {
        Solution solution = new Solution();
        TreeNode root = new TreeNode(4);
        TreeNode left = new TreeNode(2);
        TreeNode right = new TreeNode(7);
        root.left = left;
        root.right = right;
        TreeNode leftLeft = new TreeNode(1);
        TreeNode leftRight = new TreeNode(3);
        left.left = leftLeft;
        left.right = leftRight;
        TreeNode treeNode = solution.searchBST(root, 1);
        System.out.println(treeNode.val);
    }
    }
    
    public class Question1115 {

    /**
     * 思路1:通过信号量来控制,线程A:信息量A为1  线程B:信号量B为0
     * 线程A调用foo方法,获取信号量A,此时信号量A归0,输出foo后,释放信号量B A=0 B=1
     * 线程池A执行n=2的时候,阻塞在A.acquire
     * <p>
     * 线程B调用bar方法,获取信号量B,释放信号量A 当A调用完foo方法后,bar方法执行 执行完后A=1 B=0
     * 在重复上面步骤
     */
    class FooBar {
        private int n;

        private Semaphore s1 = new Semaphore(0);
        private Semaphore s2 = new Semaphore(1);

        public FooBar(int n) {
            this.n = n;
        }

        public void foo(Runnable printFoo) throws InterruptedException {

            for (int i = 0; i < n; i++) {
                // printFoo.run() outputs "foo". Do not change or remove this line.
                s2.acquire();
                printFoo.run();
                s1.release();
            }
        }

        public void bar(Runnable printBar) throws InterruptedException {

            for (int i = 0; i < n; i++) {
                // printBar.run() outputs "bar". Do not change or remove this line.
                s1.acquire();
                printBar.run();
                s2.release();
            }
        }
    }

    /**
     * 思路2:通过validate来修饰遍历+yield()
     * 初始化标致为 flag=true 此时线程A的foo方法判断 if(flag) 执行run方法,同时标志位标记位false
     * bar方法判断 if(!flag):执行run方法后标记flag为true
     */
    class FooBar2 {
        private int n;

        private volatile boolean flag = Boolean.TRUE;

        public FooBar2(int n) {
            this.n = n;
        }

        public void foo(Runnable printFoo) throws InterruptedException {

            for (int i = 0; i < n; i++) {
                // printFoo.run() outputs "foo". Do not change or remove this line.
                while (!flag) {
                    Thread.yield();
                }
                printFoo.run();
                flag = false;
            }
        }

        public void bar(Runnable printBar) throws InterruptedException {

            for (int i = 0; i < n; i++) {
                // printBar.run() outputs "bar". Do not change or remove this line.
                while (flag) {
                    Thread.yield();
                }
                printBar.run();
                flag = true;

            }
        }
    }

    /**
     * 思路3:标志位+通过lock condition来实现管程  (标志位不需要validate修饰原因是happenbefore原则:unlock操作在lock之前,flag=false在unlock操作之前,传递性 flag=false在lock操作之前)
     * 1.判断flag标志位是否满足条件,不满足进入等待队列 满足则打印
     * 逻辑:假设线程B获取到锁,此时不满足flag=false 线程B进入到等待队列中,释放锁
     *      此时线程A获取到锁,执行run方法输出foo 同时flag=false,唤醒等待队列中的线程B,线程B进入到同步队列,线程A释放锁,同步队列中取一个线程执行
     *      此时线程B在获取到锁执行输出bar.
     */
    class FooBar3 {
        private int n;

        private boolean flag = Boolean.TRUE;

        private Lock lock = new ReentrantLock();

        private Condition condition = lock.newCondition();

        public FooBar3(int n) {
            this.n = n;
        }

        public void foo(Runnable printFoo) throws InterruptedException {

            for (int i = 0; i < n; i++) {
                lock.lock();
                if (!flag) {
                    condition.await();
                }
                printFoo.run();
                flag = false;
                condition.signalAll();
                lock.unlock();
            }
        }

        public void bar(Runnable printBar) throws InterruptedException {

            for (int i = 0; i < n; i++) {
                // printBar.run() outputs "bar". Do not change or remove this line.
                lock.lock();
                if (flag) {
                    condition.await();
                }
                printBar.run();
                flag = true;
                condition.signalAll();
                lock.unlock();

            }
        }
    }

    @Test
    public void test1() {
        FooBar fooBar = new FooBar(2);
        new Thread(() -> {
            try {
                fooBar.foo(() -> System.out.print("foo"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }).start();

        new Thread(() -> {
            try {
                fooBar.bar(() -> System.out.print("bar"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }

    @Test
    public void test2() {
        FooBar2 fooBar2 = new FooBar2(3);
        new Thread(() -> {
            try {
                fooBar2.foo(() -> System.out.print("foo"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }).start();

        new Thread(() -> {
            try {
                fooBar2.bar(() -> System.out.print("bar"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }

    @Test
    public void test3() {
        FooBar3 fooBar3 = new FooBar3(3);
        new Thread(() -> {
            try {
                fooBar3.foo(() -> System.out.print("foo"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }).start();

        new Thread(() -> {
            try {
                fooBar3.bar(() -> System.out.print("bar"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
