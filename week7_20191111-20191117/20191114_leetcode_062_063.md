    
# 问题描述:
   - 不同路径 https://leetcode-cn.com/problems/unique-paths
   - 不同路径 II https://leetcode-cn.com/problems/unique-paths-ii
    
# 思路:    
    public class Question062 {

    class Solution {
        /**
         * 思路:动态规划问题:走到当前节点 (i,j)的条数为 dp[i][j] = 左边节点+上节点 = dp[i][j-1] + dp[i-1][j]
         *
         * @param m 代表列
         * @param n 代表行
         * @return
         */
        public int uniquePaths(int m, int n) {
            int[][] dp = new int[n][m];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (i == 0 || j == 0) {
                        // 当为第一行或者第一列时 走只有一种走法
                        dp[i][j] = 1;
                    } else {
                        // 走到当前节点的条数为走到当前节点左边和上边之和
                        dp[i][j] = dp[i][j - 1] + dp[i - 1][j];
                    }
                }
            }
            return dp[n - 1][m - 1];
        }
    }

    @Test
    public void test1() {
        Solution solution = new Solution();
        System.out.println(solution.uniquePaths(7, 3));
    }
    }
    
    public class Question063 {

    /**
     * 动态规划:假设走到当前节点 (i,j)的路径为dp[i][j]  那么 dp[i][j] = dp[i][j-1] + dp[i-1][j]
     * <p>
     * 但是当 (i,j)对应的为障碍物时,此时dp[i][j]=0
     */
    class Solution {
        public int uniquePathsWithObstacles(int[][] obstacleGrid) {
            int row = obstacleGrid.length;
            int column = obstacleGrid[0].length;
            if (obstacleGrid[row - 1][column - 1] == 1) {
                return 0;
            }
            int[][] dp = new int[row][column];
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < column; j++) {
                    if (obstacleGrid[i][j] == 1) {
                        dp[i][j] = 0;
                    } else if (i == 0 && j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = (j - 1 < 0 ? 0 : dp[i][j - 1]) + (i - 1 < 0 ? 0 : dp[i - 1][j]);
                    }
                }
            }
            return dp[row - 1][column - 1];
        }
    }

    @Test
    public void test1() {
        Solution solution = new Solution();
        int[][] obstacleGrid = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};
        int[][] obstacleGrid2 = {{0, 0}};
        System.out.println(solution.uniquePathsWithObstacles(obstacleGrid2));
    }
}
