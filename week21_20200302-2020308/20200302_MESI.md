## 寄存器 写缓冲区 高速缓存 

1. 寄存器:每个处理器允许的内存,这样多个线程在访问不同处理器时变量可能不一致
2. 写缓冲区:一个线程对变量的写操作进行store时可能只写入了写缓冲区,此时对其他处理器时不可见的
3. 高速缓存:写缓冲区的数据可以flush到高速缓存,高速缓存中的数据其他处理器可以读取,不过不一定读取到处理器高速缓存区,可能加入到无效队列中,这样该处理器也不能读取到数据只能读取到旧数据
4. refresh:当前处理器读取其他处理器的高速缓存或者主存中的数据强制刷新到自己的高速缓存中,可见性底层通过MESI协议来实现



## 高速缓存

![image-20200304075850796](https://note.youdao.com/yws/public/resource/62880f0147b6eccac8a4e534f57f9111/xmlnote/12D0DBB688D9441AB326707C96EF0F8C/9213)

1. flag状态: s:共享 invalidate:无效 exclusive:独占式 Modify:修改
2. 处理器之间的高速缓存通过总线连接,当数据为invalidate状态时向总线发送read请求读取数据,如果数据被多个处理器共享则为s状态;当变量被修改时,会往总线发送一个invalidate消息,等待其他处理器恢复ack invalidate消息,之后获取到对数据修改的独占锁,修改数据s状态,数据修改完成之后为modify状态;其他处理器中数据为invalidate状态,其他处理器则再次从总线发送read请求读取处理器0的高速缓存中的数据
3. 优化方式:防止多个写操作阻塞,比如对数据data01的修改时flag=s状态,会先写入到写缓冲器中,然后给总线发送invalidate消息无序等待ack invalidate,其他处理器接收到invalidate消息后也无效写入到高速缓存中写入到无效队列中
4. 有序性:
   - store load重排:处理器1的写操作写入到了写缓存区对处理器2不可见,处理器2读了一份数据则觉得read在前store在后;
   - store store:处理器1的第一个写操作发现数据是s状态,写入到写缓冲区;第二个写操作为m状态直接修改,即两个写操作顺序反过来
5. 可见性:
   - 比如处理器1写入到自己的写缓冲器中,处理器2通过总线去read数据读取到的还是旧数据
   - 处理2将validate消息写入到无效队列中,此时处理器2的高速缓存中数据还未标记为invalidate,然后处理器2读取到旧的数据