## insert锁

1. insert ... select

   ```sql
   session A:
   insert into t values(-1,-1,-1);
   session B:
   insert into t2(c,d) select (c,d) from t;
   ```

   - 此时执行session b时会对所有的区间都加上next-key lock,防止插入过程中数据不一致;binlog如果不为row导致的主从不一致
     
     

2. insert 循环写入

   ```sql
   insert into t2(c,d)  (select c+1, d from t force index(c) order by c desc limit 1); --加锁区间 (3,4] (4,无穷) next-lock key
   -- 执行流程,对t表c索引反向遍历取c=4的回表查询d,右间隙原则防止结果不一致锁(4,无穷)
   
   如果当插入的表未t时,此时会将所有区间锁住;防止插入遍历过程中有数据写入到值重复写入,并会用临时表存储t查询结果(1.先全表扫描t到临时表,临时表选择一行数据)
   ```

   

3. insert 唯一冲突

   ```sql
   insert into t values(10,10,10);
   begin;
   insert into t values(10,10,10); -- 唯一键重复  但此时会给(5,10]区间加next-lock key 读锁(防止其他事物对10这一行数据的删除)
   ```

4. insert into ... on duplicate key update

   ```sql
   insert into t values(11,10,10) on duplicate key update d=100; 
   -- 执行过程中如果唯一键重复则执行更新结果显示为row=2(insert和update都认为成功)
   ```



## 复制表

1. mysqldump

   ```sql
   mysqldump -h$host -P$port -u$user --add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a>900" --result-file=/client_tmp/t.sql
   -- --single-transaction:开启快照读的方式拷贝数据,此时不影响DML写入,对DDL采用online
   -- –add-locks:0 代表不加lock表锁
   -- --no-create-info:代表不导出表结构
   -- --set-gtid-purged=OFF:代表不输出GTID信息
   -- result...:输出文件的位置,client代表在客户端
   ```

2. 导出csv文件

   ```sql
   select * from db1.t where a>900 into outfile '/server_tmp/t.csv';
   
   load data infile '/server_tmp/t.csv' into table db2.t;
   --启动事物, 执行过程中如果报错则整个事物回滚
   ```

   

3. 物理拷贝

   - 直接拷贝.frm和.ibd文件
   - 优点:速度快 缺点:不能进行部分拷贝