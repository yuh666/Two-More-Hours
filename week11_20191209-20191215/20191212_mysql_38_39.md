## Memory

1. 主键和数据的存储是分开的,当页上有空洞的时候直接插入到空洞位置存储

2. 索引上保存数据位置的指针,称为堆组织表

3. 支持hash索引和btree,btree索引查询后的数据是有序,主键hash查询按存储位置可能无序

4. 锁粒度问题,只支持表锁不支持行锁

5. 数据持久化问题,比如master-slaver架构时,从节点重启,数据丢失,此时主节点写入一条更新语句,此时从节点接收到binlog日志后因为数据丢失更新失败;如果是master-master架构,其中一个重启后发送delete binlog给另外一个节点导致数据全部丢失

   

## 自增主键

1. innodb中自增值,保存在内存中,8.0之后自增值持久化(存储在redo log)
2. 5.7之前,mysql重启后查询max(id)+1=auto_id
3. 自增修改机制
   - 当插入一行数据id,为0,null或未指定值是,将auto_increment值当主键插入
   - 当指定值时直接插入,比如插入为X,auto_increment=Y,比较两者大小,当X<Y,是自增值不变,否则修改为新的自增值
   - 自增值生成算法:auto_increment_offset(起始值)+auto_increment_increment(步长)
4. 插入数据流程,先获取自增值,在插入当插入比如失败时自增id不回滚(提高并发若回滚则其他线程需要阻塞不然会获取到相同自增id)



## 自增锁优化

1. 参数innodb_autoinc_lock_model

   - 0:语句结束则释放锁
   - 1:普通insert,申请后直接释放;批量:insert....select,当语句批量插入完后才释放(可进行批量id申请)
   - 2:所有都是申请完后释放

2. 批量自增id申请策略

   - 第一次申请,分配1个

   - 1个用完后,同一个语句第二次申请,分配2....依次类推

   - ```sql
     insert into t values(null, 1,1);
     insert into t values(null, 2,2);
     insert into t values(null, 3,3);
     insert into t values(null, 4,4);
     create table t2 like t;
     insert into t2(c,d) select c,d from t;
     insert into t2 values(null, 5,5); -- 结果:(8,5,5)
     ```

     