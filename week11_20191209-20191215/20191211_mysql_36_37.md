## 临时表和内存表

1. 临时表

   - 可使用在各种存储引擎中,如果为innodb和MyISAM时数据写到磁盘中

   - ```sql
     create temporary table t(id int primary key) engine=innodb;
     show create table t;
     // create temporary table t(c int) engine=myisam;
     show tables;
     // 只显示普通表t(不显示临时表)
     ```

   - 一个临时表只能被创建它的session访问,对其他线程不可见

   - 临时表和普通表可以同名,show create和DDL语句都是访问的临时表

   - show table,不显示临时表,当session结束的时候自动被删除

   - 存储临时文件目录,#sql{进程id}_{线程id}_序列号,select @@tmpdir,来查看临时文件目录

     

2. 内存表

   - 指memory引擎表,建表语句是create table ... engine = memory,数据都存储在内存中,当mysql重启时数据会丢失

3. 临时表主备复制

   - 将binlog的格式设置row模式,保证备库执行不是执行DML语句,比如数据从临时表查询得到此时主从同步会报错
   - 当设置为statement和mixed时,binlog记录临时表的操作,此时主库上应该写drop table temporary table

## 内存临时表

1. union

   ```sql
   (select 1000 as f) union (select id from t1 order by id desc limit 2);
   ```

   - 创建临时表,只有一个字段f
   - 将1000插入到临时表中
   - 查询t1表,对id索引反向遍历,先取一行记录插入到临时表,判断id对应的数据是否存在临时表存在则不插入不存在则插入,同理第二行记录
   - 当使用unionall时元素可以重复此时不需要使用临时表,t1:覆盖索引查询

2. group by

   ```sql
   select id%10 as m, count(*) as c from t1 group by m;
   explain:
   extra:using index(覆盖索引查询)  using temporary(使用临时表) filter sort(排序)
   ```

   - 创建临时表,包括m和c两个字段,m为主键

   - t1的主键索引遍历,取出第一行记录,进行id%10计算后插入临时表

     - 判断值是否在临时表中存在,不存在则插入(m,1)到临时表
     - 存在,对当前m对应的c+1

   - 重复第二步操作

   - 将临时表中数据加入到sort buffer(c,m)中排序,流程:1.将临时表中数据加入到sort buffer中,此时sort buffer无序存储m和rowid,对sort buffer排序,排好序的sort buffer根据rowid回表查询临时表返回数据结果

   - group by 添加索引优化

     ```sql
     -- 先将id计算结果存储到字段中中并对字段加索引
     alter table t1 add column z int generated always as(id % 100), add index(z);
     select z, count(*) as c from t1 group by z;
     ```

   - group by 不需要排序的时候加order by null